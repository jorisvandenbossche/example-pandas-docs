

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>MultiIndex / advanced indexing &#8212; pandas 1.0.0rc0+111.ge72cd7c52 documentation</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link rel="stylesheet" href="../_static/sphinx-bootstrap.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/pandas.css" />
    <link href="../_static/css/custom.css" rel="stylesheet">
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Merge, join, and concatenate" href="merging.html" />
    <link rel="prev" title="Indexing and selecting data" href="indexing.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">

<a class="navbar-brand" href="../index.html">
  <img src="../_static/pandas.svg" class="logo" alt="logo">
</a>

<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
</button>

<div id="navbar-menu" class="collapse navbar-collapse">
  <ul id="navbar-main-elements" class="navbar-nav mr-auto">
    <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        1.0.0
      </a>
      <div class="dropdown-menu" aria-labelledby="navbarDropdown" id="version-menu"></div>
    </li>
    <li class="nav-item">
        <a class="nav-link" href="../index.html">Home</a>
    </li>
    
    
    <li class="nav-item ">
        <a class="nav-link" href="../whatsnew/v1.1.0.html">What's New in 1.1.0</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../getting_started/index.html">Getting started</a>
    </li>
    
    <li class="nav-item active">
        <a class="nav-link" href="index.html">User Guide</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../reference/index.html">API reference</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../development/index.html">Development</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../whatsnew/index.html">Release Notes</a>
    </li>
    
    
  </ul>
  <ul class="navbar-nav ml-auto">
    
      <li class="nav-item">
        <a class="nav-link" href="https://github.com/pandas-dev/pandas" target="_blank" rel="noopener">
          <span><i class="fab fa-github-square"></i></span>
        </a>
      </li>
    
    
      <li class="nav-item">
        <a class="nav-link" href="https://twitter.com/pandas_dev" target="_blank" rel="noopener">
          <span><i class="fab fa-twitter-square"></i></span>
        </a>
      </li>
    
  </ul>
</div>
    </nav>

    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 bd-sidebar">

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

  <div class="bd-toc-item active">
  

  <ul class="nav bd-sidenav">
      
      
      
      
      
      
        
          
              <li class="">
                  <a href="io.html">IO tools (text, CSV, HDF5, …)</a>
              </li>
          
        
          
              <li class="">
                  <a href="indexing.html">Indexing and selecting data</a>
              </li>
          
        
          
              <li class="active">
                  <a href="">MultiIndex / advanced indexing</a>
              </li>
          
        
          
              <li class="">
                  <a href="merging.html">Merge, join, and concatenate</a>
              </li>
          
        
          
              <li class="">
                  <a href="reshaping.html">Reshaping and pivot tables</a>
              </li>
          
        
          
              <li class="">
                  <a href="text.html">Working with text data</a>
              </li>
          
        
          
              <li class="">
                  <a href="missing_data.html">Working with missing data</a>
              </li>
          
        
          
              <li class="">
                  <a href="categorical.html">Categorical data</a>
              </li>
          
        
          
              <li class="">
                  <a href="integer_na.html">Nullable integer data type</a>
              </li>
          
        
          
              <li class="">
                  <a href="boolean.html">Nullable Boolean Data Type</a>
              </li>
          
        
          
              <li class="">
                  <a href="visualization.html">Visualization</a>
              </li>
          
        
          
              <li class="">
                  <a href="computation.html">Computational tools</a>
              </li>
          
        
          
              <li class="">
                  <a href="groupby.html">Group By: split-apply-combine</a>
              </li>
          
        
          
              <li class="">
                  <a href="timeseries.html">Time series / date functionality</a>
              </li>
          
        
          
              <li class="">
                  <a href="timedeltas.html">Time deltas</a>
              </li>
          
        
          
              <li class="">
                  <a href="style.html">Styling</a>
              </li>
          
        
          
              <li class="">
                  <a href="options.html">Options and settings</a>
              </li>
          
        
          
              <li class="">
                  <a href="enhancingperf.html">Enhancing performance</a>
              </li>
          
        
          
              <li class="">
                  <a href="scale.html">Scaling to large datasets</a>
              </li>
          
        
          
              <li class="">
                  <a href="sparse.html">Sparse data structures</a>
              </li>
          
        
          
              <li class="">
                  <a href="gotchas.html">Frequently Asked Questions (FAQ)</a>
              </li>
          
        
          
              <li class="">
                  <a href="cookbook.html">Cookbook</a>
              </li>
          
        
      
      
      
      
      
      
      
      
    </ul>

</nav>
          </div>

          <div class="d-none d-xl-block col-xl-2 bd-toc">
              
<div class="tocsection onthispage"><i class="fas fa-list"></i> On this page</div>
<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#hierarchical-indexing-multiindex" class="nav-link">Hierarchical indexing (MultiIndex)</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#creating-a-multiindex-hierarchical-index-object" class="nav-link">Creating a MultiIndex (hierarchical index) object</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#reconstructing-the-level-labels" class="nav-link">Reconstructing the level labels</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#basic-indexing-on-axis-with-multiindex" class="nav-link">Basic indexing on axis with MultiIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#defined-levels" class="nav-link">Defined levels</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#data-alignment-and-using-reindex" class="nav-link">Data alignment and using reindex</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#advanced-indexing-with-hierarchical-index" class="nav-link">Advanced indexing with hierarchical index</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#using-slicers" class="nav-link">Using slicers</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#cross-section" class="nav-link">Cross-section</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#advanced-reindexing-and-alignment" class="nav-link">Advanced reindexing and alignment</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#swapping-levels-with-swaplevel" class="nav-link">Swapping levels with swaplevel</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#reordering-levels-with-reorder-levels" class="nav-link">Reordering levels with reorder_levels</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#renaming-names-of-an-index-or-multiindex" class="nav-link">Renaming names of an Index or MultiIndex</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#sorting-a-multiindex" class="nav-link">Sorting a MultiIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#take-methods" class="nav-link">Take methods</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#index-types" class="nav-link">Index types</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#categoricalindex" class="nav-link">CategoricalIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#int64index-and-rangeindex" class="nav-link">Int64Index and RangeIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#float64index" class="nav-link">Float64Index</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#intervalindex" class="nav-link">IntervalIndex</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h4">
            <a href="#indexing-with-an-intervalindex" class="nav-link">Indexing with an IntervalIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h4">
            <a href="#binning-data-with-cut-and-qcut" class="nav-link">Binning data with cut and qcut</a>
        </li>
    
        <li class="nav-item toc-entry toc-h4">
            <a href="#generating-ranges-of-intervals" class="nav-link">Generating ranges of intervals</a>
        </li>
    
            </ul>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#miscellaneous-indexing-faq" class="nav-link">Miscellaneous indexing FAQ</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#integer-indexing" class="nav-link">Integer indexing</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#non-monotonic-indexes-require-exact-matches" class="nav-link">Non-monotonic indexes require exact matches</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#endpoints-are-inclusive" class="nav-link">Endpoints are inclusive</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#indexing-potentially-changes-underlying-series-dtype" class="nav-link">Indexing potentially changes underlying Series dtype</a>
        </li>
    
            </ul>
        </li>
    
    </ul>
</nav>
              
            </div>

          <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content" role="main">
              <div>
                
  <div class="section" id="multiindex-advanced-indexing">
<span id="advanced"></span><h1>MultiIndex / advanced indexing<a class="headerlink" href="#multiindex-advanced-indexing" title="Permalink to this headline">¶</a></h1>
<p>This section covers <a class="reference internal" href="#advanced-hierarchical"><span class="std std-ref">indexing with a MultiIndex</span></a>
and <a class="reference internal" href="#indexing-index-types"><span class="std std-ref">other advanced indexing features</span></a>.</p>
<p>See the <a class="reference internal" href="indexing.html#indexing"><span class="std std-ref">Indexing and Selecting Data</span></a> for general indexing documentation.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Whether a copy or a reference is returned for a setting operation may
depend on the context.  This is sometimes called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">assignment</span></code> and
should be avoided.  See <a class="reference internal" href="indexing.html#indexing-view-versus-copy"><span class="std std-ref">Returning a View versus Copy</span></a>.</p>
</div>
<p>See the <a class="reference internal" href="cookbook.html#cookbook-selection"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p>
<div class="section" id="hierarchical-indexing-multiindex">
<span id="advanced-hierarchical"></span><h2>Hierarchical indexing (MultiIndex)<a class="headerlink" href="#hierarchical-indexing-multiindex" title="Permalink to this headline">¶</a></h2>
<p>Hierarchical / Multi-level indexing is very exciting as it opens the door to some
quite sophisticated data analysis and manipulation, especially for working with
higher dimensional data. In essence, it enables you to store and manipulate
data with an arbitrary number of dimensions in lower dimensional data
structures like <code class="docutils literal notranslate"><span class="pre">Series</span></code> (1d) and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> (2d).</p>
<p>In this section, we will show what exactly we mean by “hierarchical” indexing
and how it integrates with all of the pandas indexing functionality
described above and in prior sections. Later, when discussing <a class="reference internal" href="groupby.html#groupby"><span class="std std-ref">group by</span></a> and <a class="reference internal" href="reshaping.html#reshaping"><span class="std std-ref">pivoting and reshaping data</span></a>, we’ll show
non-trivial applications to illustrate how it aids in structuring data for
analysis.</p>
<p>See the <a class="reference internal" href="cookbook.html#cookbook-multi-index"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.24.0: </span><code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.labels</span></code> has been renamed to <code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.codes</span></code>
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.set_labels</span></code> to <code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.set_codes</span></code>.</p>
</div>
<div class="section" id="creating-a-multiindex-hierarchical-index-object">
<h3>Creating a MultiIndex (hierarchical index) object<a class="headerlink" href="#creating-a-multiindex-hierarchical-index-object" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code> object is the hierarchical analogue of the standard
<code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code> object which typically stores the axis labels in pandas objects. You
can think of <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> as an array of tuples where each tuple is unique. A
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> can be created from a list of arrays (using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_arrays()</span></code>), an array of tuples (using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_tuples()</span></code>), a crossed set of iterables (using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_product()</span></code>), or a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code> (using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_frame()</span></code>).  The <code class="docutils literal notranslate"><span class="pre">Index</span></code> constructor will attempt to return
a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> when it is passed a list of tuples.  The following examples
demonstrate different ways to initialize MultiIndexes.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">],</span>
<span class="gp">   ...: </span>          <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]]</span>
<span class="gp">   ...: </span>

<span class="gp">In [2]: </span><span class="n">tuples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">))</span>

<span class="gp">In [3]: </span><span class="n">tuples</span>
<span class="gh">Out[3]: </span><span class="go"></span>
<span class="go">[(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go"> (&#39;baz&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;baz&#39;, &#39;two&#39;),</span>
<span class="go"> (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go"> (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;qux&#39;, &#39;two&#39;)]</span>

<span class="gp">In [4]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>

<span class="gp">In [5]: </span><span class="n">index</span>
<span class="gh">Out[5]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>

<span class="gp">In [6]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

<span class="gp">In [7]: </span><span class="n">s</span>
<span class="gh">Out[7]: </span><span class="go"></span>
<span class="go">first  second</span>
<span class="go">bar    one       0.469112</span>
<span class="go">       two      -0.282863</span>
<span class="go">baz    one      -1.509059</span>
<span class="go">       two      -1.135632</span>
<span class="go">foo    one       1.212112</span>
<span class="go">       two      -0.173215</span>
<span class="go">qux    one       0.119209</span>
<span class="go">       two      -1.044236</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>When you want every pairing of the elements in two iterables, it can be easier
to use the <code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_product()</span></code> method:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">iterables</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]]</span>

<span class="gp">In [9]: </span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span><span class="n">iterables</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>
<span class="gh">Out[9]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>
</pre></div>
</div>
<p>You can also construct a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> directly, using
the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_frame()</span></code>. This is a complementary method to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.to_frame()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [10]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">],</span>
<span class="gp">   ....: </span>                   <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]],</span>
<span class="gp">   ....: </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>
<span class="gp">   ....: </span>

<span class="gp">In [11]: </span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_frame</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gh">Out[11]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>
</pre></div>
</div>
<p>As a convenience, you can pass a list of arrays directly into <code class="docutils literal notranslate"><span class="pre">Series</span></code> or
<code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to construct a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> automatically:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">]),</span>
<span class="gp">   ....: </span>          <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">])]</span>
<span class="gp">   ....: </span>

<span class="gp">In [13]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">arrays</span><span class="p">)</span>

<span class="gp">In [14]: </span><span class="n">s</span>
<span class="gh">Out[14]: </span><span class="go"></span>
<span class="go">bar  one   -0.861849</span>
<span class="go">     two   -2.104569</span>
<span class="go">baz  one   -0.494929</span>
<span class="go">     two    1.071804</span>
<span class="go">foo  one    0.721555</span>
<span class="go">     two   -0.706771</span>
<span class="go">qux  one   -1.039575</span>
<span class="go">     two    0.271860</span>
<span class="go">dtype: float64</span>

<span class="gp">In [15]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">arrays</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">df</span>
<span class="gh">Out[16]: </span><span class="go"></span>
<span class="go">                0         1         2         3</span>
<span class="go">bar one -0.424972  0.567020  0.276232 -1.087401</span>
<span class="go">    two -0.673690  0.113648 -1.478427  0.524988</span>
<span class="go">baz one  0.404705  0.577046 -1.715002 -1.039268</span>
<span class="go">    two -0.370647 -1.157892 -1.344312  0.844885</span>
<span class="go">foo one  1.075770 -0.109050  1.643563 -1.469388</span>
<span class="go">    two  0.357021 -0.674600 -1.776904 -0.968914</span>
<span class="go">qux one -1.294524  0.413738  0.276662 -0.472035</span>
<span class="go">    two -0.013960 -0.362543 -0.006154 -0.923061</span>
</pre></div>
</div>
<p>All of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> constructors accept a <code class="docutils literal notranslate"><span class="pre">names</span></code> argument which stores
string names for the levels themselves. If no names are provided, <code class="docutils literal notranslate"><span class="pre">None</span></code> will
be assigned:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [17]: </span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
<span class="gh">Out[17]: </span><span class="go">FrozenList([None, None])</span>
</pre></div>
</div>
<p>This index can back any axis of a pandas object, and the number of <strong>levels</strong>
of the index is up to you:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [18]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

<span class="gp">In [19]: </span><span class="n">df</span>
<span class="gh">Out[19]: </span><span class="go"></span>
<span class="go">first        bar                 baz                 foo                 qux          </span>
<span class="go">second       one       two       one       two       one       two       one       two</span>
<span class="go">A       0.895717  0.805244 -1.206412  2.565646  1.431256  1.340309 -1.170299 -0.226169</span>
<span class="go">B       0.410835  0.813850  0.132003 -0.827317 -0.076467 -1.187678  1.130127 -1.436737</span>
<span class="go">C      -1.413681  1.607920  1.024180  0.569605  0.875906 -2.211372  0.974466 -2.006747</span>

<span class="gp">In [20]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">[:</span><span class="mi">6</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">index</span><span class="p">[:</span><span class="mi">6</span><span class="p">])</span>
<span class="gh">Out[20]: </span><span class="go"></span>
<span class="go">first              bar                 baz                 foo          </span>
<span class="go">second             one       two       one       two       one       two</span>
<span class="go">first second                                                            </span>
<span class="go">bar   one    -0.410001 -0.078638  0.545952 -1.219217 -1.226825  0.769804</span>
<span class="go">      two    -1.281247 -0.727707 -0.121306 -0.097883  0.695775  0.341734</span>
<span class="go">baz   one     0.959726 -1.110336 -0.619976  0.149748 -0.732339  0.687738</span>
<span class="go">      two     0.176444  0.403310 -0.154951  0.301624 -2.179861 -1.369849</span>
<span class="go">foo   one    -0.954208  1.462696 -1.743161 -0.826591 -0.345352  1.314232</span>
<span class="go">      two     0.690579  0.995761  2.396780  0.014871  3.357427 -0.317441</span>
</pre></div>
</div>
<p>We’ve “sparsified” the higher levels of the indexes to make the console output a
bit easier on the eyes. Note that how the index is displayed can be controlled using the
<code class="docutils literal notranslate"><span class="pre">multi_sparse</span></code> option in <code class="docutils literal notranslate"><span class="pre">pandas.set_options()</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [21]: </span><span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">option_context</span><span class="p">(</span><span class="s1">&#39;display.multi_sparse&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">df</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>It’s worth keeping in mind that there’s nothing preventing you from using
tuples as atomic labels on an axis:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [22]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">tuples</span><span class="p">)</span>
<span class="gh">Out[22]: </span><span class="go"></span>
<span class="go">(bar, one)   -1.236269</span>
<span class="go">(bar, two)    0.896171</span>
<span class="go">(baz, one)   -0.487602</span>
<span class="go">(baz, two)   -0.082240</span>
<span class="go">(foo, one)   -2.182937</span>
<span class="go">(foo, two)    0.380396</span>
<span class="go">(qux, one)    0.084844</span>
<span class="go">(qux, two)    0.432390</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>The reason that the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> matters is that it can allow you to do
grouping, selection, and reshaping operations as we will describe below and in
subsequent areas of the documentation. As you will see in later sections, you
can find yourself working with hierarchically-indexed data without creating a
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> explicitly yourself. However, when loading data from a file, you
may wish to generate your own <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> when preparing the data set.</p>
</div>
<div class="section" id="reconstructing-the-level-labels">
<span id="advanced-get-level-values"></span><h3>Reconstructing the level labels<a class="headerlink" href="#reconstructing-the-level-labels" title="Permalink to this headline">¶</a></h3>
<p>The method <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_level_values()</span></code> will return a vector of the labels for each
location at a particular level:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [23]: </span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gh">Out[23]: </span><span class="go">Index([&#39;bar&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;baz&#39;, &#39;foo&#39;, &#39;foo&#39;, &#39;qux&#39;, &#39;qux&#39;], dtype=&#39;object&#39;, name=&#39;first&#39;)</span>

<span class="gp">In [24]: </span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">)</span>
<span class="gh">Out[24]: </span><span class="go">Index([&#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;], dtype=&#39;object&#39;, name=&#39;second&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="basic-indexing-on-axis-with-multiindex">
<h3>Basic indexing on axis with MultiIndex<a class="headerlink" href="#basic-indexing-on-axis-with-multiindex" title="Permalink to this headline">¶</a></h3>
<p>One of the important features of hierarchical indexing is that you can select
data by a “partial” label identifying a subgroup in the data. <strong>Partial</strong>
selection “drops” levels of the hierarchical index in the result in a
completely analogous way to selecting a column in a regular DataFrame:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [25]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span>
<span class="gh">Out[25]: </span><span class="go"></span>
<span class="go">second       one       two</span>
<span class="go">A       0.895717  0.805244</span>
<span class="go">B       0.410835  0.813850</span>
<span class="go">C      -1.413681  1.607920</span>

<span class="gp">In [26]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">]</span>
<span class="gh">Out[26]: </span><span class="go"></span>
<span class="go">A    0.895717</span>
<span class="go">B    0.410835</span>
<span class="go">C   -1.413681</span>
<span class="go">Name: (bar, one), dtype: float64</span>

<span class="gp">In [27]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">][</span><span class="s1">&#39;one&#39;</span><span class="p">]</span>
<span class="gh">Out[27]: </span><span class="go"></span>
<span class="go">A    0.895717</span>
<span class="go">B    0.410835</span>
<span class="go">C   -1.413681</span>
<span class="go">Name: one, dtype: float64</span>

<span class="gp">In [28]: </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;qux&#39;</span><span class="p">]</span>
<span class="gh">Out[28]: </span><span class="go"></span>
<span class="go">one   -1.039575</span>
<span class="go">two    0.271860</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#advanced-xs"><span class="std std-ref">Cross-section with hierarchical index</span></a> for how to select
on a deeper level.</p>
</div>
<div class="section" id="defined-levels">
<span id="advanced-shown-levels"></span><h3>Defined levels<a class="headerlink" href="#defined-levels" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code> keeps all the defined levels of an index, even
if they are not actually used. When slicing an index, you may notice this.
For example:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [29]: </span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">levels</span>  <span class="c1"># original MultiIndex</span>
<span class="gh">Out[29]: </span><span class="go">FrozenList([[&#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;, &#39;qux&#39;], [&#39;one&#39;, &#39;two&#39;]])</span>

<span class="gp">In [30]: </span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span><span class="s1">&#39;qux&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">levels</span>  <span class="c1"># sliced</span>
<span class="gh">Out[30]: </span><span class="go">FrozenList([[&#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;, &#39;qux&#39;], [&#39;one&#39;, &#39;two&#39;]])</span>
</pre></div>
</div>
<p>This is done to avoid a recomputation of the levels in order to make slicing
highly performant. If you want to see only the used levels, you can use the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_level_values()</span></code> method.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [31]: </span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="gh">Out[31]: </span><span class="go"></span>
<span class="go">array([(&#39;foo&#39;, &#39;one&#39;), (&#39;foo&#39;, &#39;two&#39;), (&#39;qux&#39;, &#39;one&#39;), (&#39;qux&#39;, &#39;two&#39;)],</span>
<span class="go">      dtype=object)</span>

<span class="go"># for a specific level</span>
<span class="gp">In [32]: </span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gh">Out[32]: </span><span class="go">Index([&#39;foo&#39;, &#39;foo&#39;, &#39;qux&#39;, &#39;qux&#39;], dtype=&#39;object&#39;, name=&#39;first&#39;)</span>
</pre></div>
</div>
<p>To reconstruct the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> with only the used levels, the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_unused_levels()</span></code> method may be used.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [33]: </span><span class="n">new_mi</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">remove_unused_levels</span><span class="p">()</span>

<span class="gp">In [34]: </span><span class="n">new_mi</span><span class="o">.</span><span class="n">levels</span>
<span class="gh">Out[34]: </span><span class="go">FrozenList([[&#39;foo&#39;, &#39;qux&#39;], [&#39;one&#39;, &#39;two&#39;]])</span>
</pre></div>
</div>
</div>
<div class="section" id="data-alignment-and-using-reindex">
<h3>Data alignment and using <code class="docutils literal notranslate"><span class="pre">reindex</span></code><a class="headerlink" href="#data-alignment-and-using-reindex" title="Permalink to this headline">¶</a></h3>
<p>Operations between differently-indexed objects having <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> on the
axes will work as you expect; data alignment will work the same as an Index of
tuples:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [35]: </span><span class="n">s</span> <span class="o">+</span> <span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gh">Out[35]: </span><span class="go"></span>
<span class="go">bar  one   -1.723698</span>
<span class="go">     two   -4.209138</span>
<span class="go">baz  one   -0.989859</span>
<span class="go">     two    2.143608</span>
<span class="go">foo  one    1.443110</span>
<span class="go">     two   -1.413542</span>
<span class="go">qux  one         NaN</span>
<span class="go">     two         NaN</span>
<span class="go">dtype: float64</span>

<span class="gp">In [36]: </span><span class="n">s</span> <span class="o">+</span> <span class="n">s</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gh">Out[36]: </span><span class="go"></span>
<span class="go">bar  one   -1.723698</span>
<span class="go">     two         NaN</span>
<span class="go">baz  one   -0.989859</span>
<span class="go">     two         NaN</span>
<span class="go">foo  one    1.443110</span>
<span class="go">     two         NaN</span>
<span class="go">qux  one   -2.079150</span>
<span class="go">     two         NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code> method of <code class="docutils literal notranslate"><span class="pre">Series</span></code>/<code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> can be
called with another <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, or even a list or array of tuples:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [37]: </span><span class="n">s</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
<span class="gh">Out[37]: </span><span class="go"></span>
<span class="go">first  second</span>
<span class="go">bar    one      -0.861849</span>
<span class="go">       two      -2.104569</span>
<span class="go">baz    one      -0.494929</span>
<span class="go">dtype: float64</span>

<span class="gp">In [38]: </span><span class="n">s</span><span class="o">.</span><span class="n">reindex</span><span class="p">([(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">)])</span>
<span class="gh">Out[38]: </span><span class="go"></span>
<span class="go">foo  two   -0.706771</span>
<span class="go">bar  one   -0.861849</span>
<span class="go">qux  one   -1.039575</span>
<span class="go">baz  one   -0.494929</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="advanced-indexing-with-hierarchical-index">
<span id="advanced-advanced-hierarchical"></span><h2>Advanced indexing with hierarchical index<a class="headerlink" href="#advanced-indexing-with-hierarchical-index" title="Permalink to this headline">¶</a></h2>
<p>Syntactically integrating <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> in advanced indexing with <code class="docutils literal notranslate"><span class="pre">.loc</span></code> is a
bit challenging, but we’ve made every effort to do so. In general, MultiIndex
keys take the form of tuples. For example, the following works as you would expect:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [39]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">T</span>

<span class="gp">In [40]: </span><span class="n">df</span>
<span class="gh">Out[40]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">bar   one     0.895717  0.410835 -1.413681</span>
<span class="go">      two     0.805244  0.813850  1.607920</span>
<span class="go">baz   one    -1.206412  0.132003  1.024180</span>
<span class="go">      two     2.565646 -0.827317  0.569605</span>
<span class="go">foo   one     1.431256 -0.076467  0.875906</span>
<span class="go">      two     1.340309 -1.187678 -2.211372</span>
<span class="go">qux   one    -1.170299  1.130127  0.974466</span>
<span class="go">      two    -0.226169 -1.436737 -2.006747</span>

<span class="gp">In [41]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">)]</span>
<span class="gh">Out[41]: </span><span class="go"></span>
<span class="go">A    0.805244</span>
<span class="go">B    0.813850</span>
<span class="go">C    1.607920</span>
<span class="go">Name: (bar, two), dtype: float64</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">df.loc['bar',</span> <span class="pre">'two']</span></code> would also work in this example, but this shorthand
notation can lead to ambiguity in general.</p>
<p>If you also want to index a specific column with <code class="docutils literal notranslate"><span class="pre">.loc</span></code>, you must use a tuple
like this:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [42]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">),</span> <span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gh">Out[42]: </span><span class="go">0.8052440253863785</span>
</pre></div>
</div>
<p>You don’t have to specify all levels of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> by passing only the
first elements of the tuple. For example, you can use “partial” indexing to
get all elements with <code class="docutils literal notranslate"><span class="pre">bar</span></code> in the first level as follows:</p>
<p>df.loc[‘bar’]</p>
<p>This is a shortcut for the slightly more verbose notation <code class="docutils literal notranslate"><span class="pre">df.loc[('bar',),]</span></code> (equivalent
to <code class="docutils literal notranslate"><span class="pre">df.loc['bar',]</span></code> in this example).</p>
<p>“Partial” slicing also works quite nicely.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [43]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;baz&#39;</span><span class="p">:</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
<span class="gh">Out[43]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">baz   one    -1.206412  0.132003  1.024180</span>
<span class="go">      two     2.565646 -0.827317  0.569605</span>
<span class="go">foo   one     1.431256 -0.076467  0.875906</span>
<span class="go">      two     1.340309 -1.187678 -2.211372</span>
</pre></div>
</div>
<p>You can slice with a ‘range’ of values, by providing a slice of tuples.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [44]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">):(</span><span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">)]</span>
<span class="gh">Out[44]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">baz   two     2.565646 -0.827317  0.569605</span>
<span class="go">foo   one     1.431256 -0.076467  0.875906</span>
<span class="go">      two     1.340309 -1.187678 -2.211372</span>
<span class="go">qux   one    -1.170299  1.130127  0.974466</span>

<span class="gp">In [45]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">):</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
<span class="gh">Out[45]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">baz   two     2.565646 -0.827317  0.569605</span>
<span class="go">foo   one     1.431256 -0.076467  0.875906</span>
<span class="go">      two     1.340309 -1.187678 -2.211372</span>
</pre></div>
</div>
<p>Passing a list of labels or tuples works similar to reindexing:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [46]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[[(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">)]]</span>
<span class="gh">Out[46]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">bar   two     0.805244  0.813850  1.607920</span>
<span class="go">qux   one    -1.170299  1.130127  0.974466</span>
</pre></div>
</div>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>It is important to note that tuples and lists are not treated identically
in pandas when it comes to indexing. Whereas a tuple is interpreted as one
multi-level key, a list is used to specify several keys. Or in other words,
tuples go horizontally (traversing levels), lists go vertically (scanning levels).</p>
</div>
<p>Importantly, a list of tuples indexes several complete <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> keys,
whereas a tuple of lists refer to several values within a level:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [47]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">   ....: </span>              <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">]]))</span>
<span class="gp">   ....: </span>

<span class="gp">In [48]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[[(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)]]</span>  <span class="c1"># list of tuples</span>
<span class="gh">Out[48]: </span><span class="go"></span>
<span class="go">A  c    1</span>
<span class="go">B  d    5</span>
<span class="go">dtype: int64</span>

<span class="gp">In [49]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[([</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">])]</span>  <span class="c1"># tuple of lists</span>
<span class="gh">Out[49]: </span><span class="go"></span>
<span class="go">A  c    1</span>
<span class="go">   d    2</span>
<span class="go">B  c    4</span>
<span class="go">   d    5</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="section" id="using-slicers">
<span id="advanced-mi-slicers"></span><h3>Using slicers<a class="headerlink" href="#using-slicers" title="Permalink to this headline">¶</a></h3>
<p>You can slice a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> by providing multiple indexers.</p>
<p>You can provide any of the selectors as if you are indexing by label, see <a class="reference internal" href="indexing.html#indexing-label"><span class="std std-ref">Selection by Label</span></a>,
including slices, lists of labels, labels, and boolean indexers.</p>
<p>You can use <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code> to select all the contents of <em>that</em> level. You do not need to specify all the
<em>deeper</em> levels, they will be implied as <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code>.</p>
<p>As usual, <strong>both sides</strong> of the slicers are included as this is label indexing.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>You should specify all axes in the <code class="docutils literal notranslate"><span class="pre">.loc</span></code> specifier, meaning the indexer for the <strong>index</strong> and
for the <strong>columns</strong>. There are some ambiguous cases where the passed indexer could be mis-interpreted
as indexing <em>both</em> axes, rather than into say the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> for the rows.</p>
<p>You should do this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A3&#39;</span><span class="p">),</span> <span class="o">...</span><span class="p">),</span> <span class="p">:]</span>             <span class="c1"># noqa: E999</span>
</pre></div>
</div>
<p>You should <strong>not</strong> do this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A3&#39;</span><span class="p">),</span> <span class="o">...</span><span class="p">)]</span>                <span class="c1"># noqa: E999</span>
</pre></div>
</div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [50]: </span><span class="k">def</span> <span class="nf">mklbl</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="gp">   ....: </span>

<span class="gp">In [51]: </span><span class="n">miindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="gp">   ....: </span>                                      <span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">   ....: </span>                                      <span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="gp">   ....: </span>                                      <span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">   ....: </span>

<span class="gp">In [52]: </span><span class="n">micolumns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">),</span>
<span class="gp">   ....: </span>                                       <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;bah&#39;</span><span class="p">)],</span>
<span class="gp">   ....: </span>                                      <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lvl0&#39;</span><span class="p">,</span> <span class="s1">&#39;lvl1&#39;</span><span class="p">])</span>
<span class="gp">   ....: </span>

<span class="gp">In [53]: </span><span class="n">dfmi</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">miindex</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">micolumns</span><span class="p">))</span>
<span class="gp">   ....: </span>                      <span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">miindex</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">micolumns</span><span class="p">))),</span>
<span class="gp">   ....: </span>                    <span class="n">index</span><span class="o">=</span><span class="n">miindex</span><span class="p">,</span>
<span class="gp">   ....: </span>                    <span class="n">columns</span><span class="o">=</span><span class="n">micolumns</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [54]: </span><span class="n">dfmi</span>
<span class="gh">Out[54]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A0 B0 C0 D0    1    0    3    2</span>
<span class="go">         D1    5    4    7    6</span>
<span class="go">      C1 D0    9    8   11   10</span>
<span class="go">         D1   13   12   15   14</span>
<span class="go">      C2 D0   17   16   19   18</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B1 C1 D1  237  236  239  238</span>
<span class="go">      C2 D0  241  240  243  242</span>
<span class="go">         D1  245  244  247  246</span>
<span class="go">      C3 D0  249  248  251  250</span>
<span class="go">         D1  253  252  255  254</span>

<span class="go">[64 rows x 4 columns]</span>
</pre></div>
</div>
<p>Basic MultiIndex slicing using slices, lists, and labels.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [55]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A3&#39;</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]),</span> <span class="p">:]</span>
<span class="gh">Out[55]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A1 B0 C1 D0   73   72   75   74</span>
<span class="go">         D1   77   76   79   78</span>
<span class="go">      C3 D0   89   88   91   90</span>
<span class="go">         D1   93   92   95   94</span>
<span class="go">   B1 C1 D0  105  104  107  106</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B0 C3 D1  221  220  223  222</span>
<span class="go">   B1 C1 D0  233  232  235  234</span>
<span class="go">         D1  237  236  239  238</span>
<span class="go">      C3 D0  249  248  251  250</span>
<span class="go">         D1  253  252  255  254</span>

<span class="go">[24 rows x 4 columns]</span>
</pre></div>
</div>
<p>You can use <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.IndexSlice</span></code> to facilitate a more natural syntax
using <code class="docutils literal notranslate"><span class="pre">:</span></code>, rather than using <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [56]: </span><span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">IndexSlice</span>

<span class="gp">In [57]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[:,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]]</span>
<span class="gh">Out[57]: </span><span class="go"></span>
<span class="go">lvl0           a    b</span>
<span class="go">lvl1         foo  foo</span>
<span class="go">A0 B0 C1 D0    8   10</span>
<span class="go">         D1   12   14</span>
<span class="go">      C3 D0   24   26</span>
<span class="go">         D1   28   30</span>
<span class="go">   B1 C1 D0   40   42</span>
<span class="go">...          ...  ...</span>
<span class="go">A3 B0 C3 D1  220  222</span>
<span class="go">   B1 C1 D0  232  234</span>
<span class="go">         D1  236  238</span>
<span class="go">      C3 D0  248  250</span>
<span class="go">         D1  252  254</span>

<span class="go">[32 rows x 2 columns]</span>
</pre></div>
</div>
<p>It is possible to perform quite complicated selections using this method on multiple
axes at the same time.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [58]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="s1">&#39;foo&#39;</span><span class="p">)]</span>
<span class="gh">Out[58]: </span><span class="go"></span>
<span class="go">lvl0        a    b</span>
<span class="go">lvl1      foo  foo</span>
<span class="go">B0 C0 D0   64   66</span>
<span class="go">      D1   68   70</span>
<span class="go">   C1 D0   72   74</span>
<span class="go">      D1   76   78</span>
<span class="go">   C2 D0   80   82</span>
<span class="go">...       ...  ...</span>
<span class="go">B1 C1 D1  108  110</span>
<span class="go">   C2 D0  112  114</span>
<span class="go">      D1  116  118</span>
<span class="go">   C3 D0  120  122</span>
<span class="go">      D1  124  126</span>

<span class="go">[16 rows x 2 columns]</span>

<span class="gp">In [59]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[:,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]]</span>
<span class="gh">Out[59]: </span><span class="go"></span>
<span class="go">lvl0           a    b</span>
<span class="go">lvl1         foo  foo</span>
<span class="go">A0 B0 C1 D0    8   10</span>
<span class="go">         D1   12   14</span>
<span class="go">      C3 D0   24   26</span>
<span class="go">         D1   28   30</span>
<span class="go">   B1 C1 D0   40   42</span>
<span class="go">...          ...  ...</span>
<span class="go">A3 B0 C3 D1  220  222</span>
<span class="go">   B1 C1 D0  232  234</span>
<span class="go">         D1  236  238</span>
<span class="go">      C3 D0  248  250</span>
<span class="go">         D1  252  254</span>

<span class="go">[32 rows x 2 columns]</span>
</pre></div>
</div>
<p>Using a boolean indexer you can provide selection related to the <em>values</em>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [60]: </span><span class="n">mask</span> <span class="o">=</span> <span class="n">dfmi</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="mi">200</span>

<span class="gp">In [61]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[:,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]]</span>
<span class="gh">Out[61]: </span><span class="go"></span>
<span class="go">lvl0           a    b</span>
<span class="go">lvl1         foo  foo</span>
<span class="go">A3 B0 C1 D1  204  206</span>
<span class="go">      C3 D0  216  218</span>
<span class="go">         D1  220  222</span>
<span class="go">   B1 C1 D0  232  234</span>
<span class="go">         D1  236  238</span>
<span class="go">      C3 D0  248  250</span>
<span class="go">         D1  252  254</span>
</pre></div>
</div>
<p>You can also specify the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument to <code class="docutils literal notranslate"><span class="pre">.loc</span></code> to interpret the passed
slicers on a single axis.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [62]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]]</span>
<span class="gh">Out[62]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A0 B0 C1 D0    9    8   11   10</span>
<span class="go">         D1   13   12   15   14</span>
<span class="go">      C3 D0   25   24   27   26</span>
<span class="go">         D1   29   28   31   30</span>
<span class="go">   B1 C1 D0   41   40   43   42</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B0 C3 D1  221  220  223  222</span>
<span class="go">   B1 C1 D0  233  232  235  234</span>
<span class="go">         D1  237  236  239  238</span>
<span class="go">      C3 D0  249  248  251  250</span>
<span class="go">         D1  253  252  255  254</span>

<span class="go">[32 rows x 4 columns]</span>
</pre></div>
</div>
<p>Furthermore, you can <em>set</em> the values using the following methods.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [63]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">dfmi</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [64]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>

<span class="gp">In [65]: </span><span class="n">df2</span>
<span class="gh">Out[65]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A0 B0 C0 D0    1    0    3    2</span>
<span class="go">         D1    5    4    7    6</span>
<span class="go">      C1 D0  -10  -10  -10  -10</span>
<span class="go">         D1  -10  -10  -10  -10</span>
<span class="go">      C2 D0   17   16   19   18</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B1 C1 D1  -10  -10  -10  -10</span>
<span class="go">      C2 D0  241  240  243  242</span>
<span class="go">         D1  245  244  247  246</span>
<span class="go">      C3 D0  -10  -10  -10  -10</span>
<span class="go">         D1  -10  -10  -10  -10</span>

<span class="go">[64 rows x 4 columns]</span>
</pre></div>
</div>
<p>You can use a right-hand-side of an alignable object as well.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [66]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">dfmi</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [67]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">df2</span> <span class="o">*</span> <span class="mi">1000</span>

<span class="gp">In [68]: </span><span class="n">df2</span>
<span class="gh">Out[68]: </span><span class="go"></span>
<span class="go">lvl0              a               b        </span>
<span class="go">lvl1            bar     foo     bah     foo</span>
<span class="go">A0 B0 C0 D0       1       0       3       2</span>
<span class="go">         D1       5       4       7       6</span>
<span class="go">      C1 D0    9000    8000   11000   10000</span>
<span class="go">         D1   13000   12000   15000   14000</span>
<span class="go">      C2 D0      17      16      19      18</span>
<span class="go">...             ...     ...     ...     ...</span>
<span class="go">A3 B1 C1 D1  237000  236000  239000  238000</span>
<span class="go">      C2 D0     241     240     243     242</span>
<span class="go">         D1     245     244     247     246</span>
<span class="go">      C3 D0  249000  248000  251000  250000</span>
<span class="go">         D1  253000  252000  255000  254000</span>

<span class="go">[64 rows x 4 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="cross-section">
<span id="advanced-xs"></span><h3>Cross-section<a class="headerlink" href="#cross-section" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">xs()</span></code> method of <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> additionally takes a level argument to make
selecting data at a particular level of a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> easier.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [69]: </span><span class="n">df</span>
<span class="gh">Out[69]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">bar   one     0.895717  0.410835 -1.413681</span>
<span class="go">      two     0.805244  0.813850  1.607920</span>
<span class="go">baz   one    -1.206412  0.132003  1.024180</span>
<span class="go">      two     2.565646 -0.827317  0.569605</span>
<span class="go">foo   one     1.431256 -0.076467  0.875906</span>
<span class="go">      two     1.340309 -1.187678 -2.211372</span>
<span class="go">qux   one    -1.170299  1.130127  0.974466</span>
<span class="go">      two    -0.226169 -1.436737 -2.006747</span>

<span class="gp">In [70]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">)</span>
<span class="gh">Out[70]: </span><span class="go"></span>
<span class="go">              A         B         C</span>
<span class="go">first                              </span>
<span class="go">bar    0.895717  0.410835 -1.413681</span>
<span class="go">baz   -1.206412  0.132003  1.024180</span>
<span class="go">foo    1.431256 -0.076467  0.875906</span>
<span class="go">qux   -1.170299  1.130127  0.974466</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># using the slicers</span>
<span class="gp">In [71]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="p">:]</span>
<span class="gh">Out[71]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">bar   one     0.895717  0.410835 -1.413681</span>
<span class="go">baz   one    -1.206412  0.132003  1.024180</span>
<span class="go">foo   one     1.431256 -0.076467  0.875906</span>
<span class="go">qux   one    -1.170299  1.130127  0.974466</span>
</pre></div>
</div>
<p>You can also select on the columns with <code class="docutils literal notranslate"><span class="pre">xs</span></code>, by
providing the axis argument.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [72]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">T</span>

<span class="gp">In [73]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[73]: </span><span class="go"></span>
<span class="go">first       bar       baz       foo       qux</span>
<span class="go">A      0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B      0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C     -1.413681  1.024180  0.875906  0.974466</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># using the slicers</span>
<span class="gp">In [74]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="s1">&#39;one&#39;</span><span class="p">)]</span>
<span class="gh">Out[74]: </span><span class="go"></span>
<span class="go">first        bar       baz       foo       qux</span>
<span class="go">second       one       one       one       one</span>
<span class="go">A       0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B       0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C      -1.413681  1.024180  0.875906  0.974466</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">xs</span></code> also allows selection with multiple keys.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [75]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">((</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">),</span> <span class="n">level</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="s1">&#39;first&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[75]: </span><span class="go"></span>
<span class="go">first        bar</span>
<span class="go">second       one</span>
<span class="go">A       0.895717</span>
<span class="go">B       0.410835</span>
<span class="go">C      -1.413681</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># using the slicers</span>
<span class="gp">In [76]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">)]</span>
<span class="gh">Out[76]: </span><span class="go"></span>
<span class="go">A    0.895717</span>
<span class="go">B    0.410835</span>
<span class="go">C   -1.413681</span>
<span class="go">Name: (bar, one), dtype: float64</span>
</pre></div>
</div>
<p>You can pass <code class="docutils literal notranslate"><span class="pre">drop_level=False</span></code> to <code class="docutils literal notranslate"><span class="pre">xs</span></code> to retain
the level that was selected.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [77]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gh">Out[77]: </span><span class="go"></span>
<span class="go">first        bar       baz       foo       qux</span>
<span class="go">second       one       one       one       one</span>
<span class="go">A       0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B       0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C      -1.413681  1.024180  0.875906  0.974466</span>
</pre></div>
</div>
<p>Compare the above with the result using <code class="docutils literal notranslate"><span class="pre">drop_level=True</span></code> (the default value).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [78]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gh">Out[78]: </span><span class="go"></span>
<span class="go">first       bar       baz       foo       qux</span>
<span class="go">A      0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B      0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C     -1.413681  1.024180  0.875906  0.974466</span>
</pre></div>
</div>
</div>
<div class="section" id="advanced-reindexing-and-alignment">
<span id="advanced-advanced-reindex"></span><h3>Advanced reindexing and alignment<a class="headerlink" href="#advanced-reindexing-and-alignment" title="Permalink to this headline">¶</a></h3>
<p>Using the parameter <code class="docutils literal notranslate"><span class="pre">level</span></code> in the <code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">align()</span></code> methods of pandas objects is useful to broadcast
values across a level. For instance:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [79]: </span><span class="n">midx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">(</span><span class="n">levels</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]],</span>
<span class="gp">   ....: </span>                     <span class="n">codes</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">   ....: </span>

<span class="gp">In [80]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">midx</span><span class="p">)</span>

<span class="gp">In [81]: </span><span class="n">df</span>
<span class="gh">Out[81]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">one  y  1.519970 -0.493662</span>
<span class="go">     x  0.600178  0.274230</span>
<span class="go">zero y  0.132885 -0.023688</span>
<span class="go">     x  2.410179  1.450520</span>

<span class="gp">In [82]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="gp">In [83]: </span><span class="n">df2</span>
<span class="gh">Out[83]: </span><span class="go"></span>
<span class="go">             0         1</span>
<span class="go">one   1.060074 -0.109716</span>
<span class="go">zero  1.271532  0.713416</span>

<span class="gp">In [84]: </span><span class="n">df2</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gh">Out[84]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">one  y  1.060074 -0.109716</span>
<span class="go">     x  1.060074 -0.109716</span>
<span class="go">zero y  1.271532  0.713416</span>
<span class="go">     x  1.271532  0.713416</span>

<span class="go"># aligning</span>
<span class="gp">In [85]: </span><span class="n">df_aligned</span><span class="p">,</span> <span class="n">df2_aligned</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="gp">In [86]: </span><span class="n">df_aligned</span>
<span class="gh">Out[86]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">one  y  1.519970 -0.493662</span>
<span class="go">     x  0.600178  0.274230</span>
<span class="go">zero y  0.132885 -0.023688</span>
<span class="go">     x  2.410179  1.450520</span>

<span class="gp">In [87]: </span><span class="n">df2_aligned</span>
<span class="gh">Out[87]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">one  y  1.060074 -0.109716</span>
<span class="go">     x  1.060074 -0.109716</span>
<span class="go">zero y  1.271532  0.713416</span>
<span class="go">     x  1.271532  0.713416</span>
</pre></div>
</div>
</div>
<div class="section" id="swapping-levels-with-swaplevel">
<h3>Swapping levels with <code class="docutils literal notranslate"><span class="pre">swaplevel</span></code><a class="headerlink" href="#swapping-levels-with-swaplevel" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">swaplevel()</span></code> method can switch the order of two levels:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [88]: </span><span class="n">df</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="gh">Out[88]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">one  y  1.519970 -0.493662</span>
<span class="go">     x  0.600178  0.274230</span>
<span class="go">zero y  0.132885 -0.023688</span>
<span class="go">     x  2.410179  1.450520</span>

<span class="gp">In [89]: </span><span class="n">df</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gh">Out[89]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">y one   1.519970 -0.493662</span>
<span class="go">x one   0.600178  0.274230</span>
<span class="go">y zero  0.132885 -0.023688</span>
<span class="go">x zero  2.410179  1.450520</span>
</pre></div>
</div>
</div>
<div class="section" id="reordering-levels-with-reorder-levels">
<span id="advanced-reorderlevels"></span><h3>Reordering levels with <code class="docutils literal notranslate"><span class="pre">reorder_levels</span></code><a class="headerlink" href="#reordering-levels-with-reorder-levels" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">reorder_levels()</span></code> method generalizes the <code class="docutils literal notranslate"><span class="pre">swaplevel</span></code>
method, allowing you to permute the hierarchical index levels in one step:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [90]: </span><span class="n">df</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gh">Out[90]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">y one   1.519970 -0.493662</span>
<span class="go">x one   0.600178  0.274230</span>
<span class="go">y zero  0.132885 -0.023688</span>
<span class="go">x zero  2.410179  1.450520</span>
</pre></div>
</div>
</div>
<div class="section" id="renaming-names-of-an-index-or-multiindex">
<span id="advanced-index-names"></span><h3>Renaming names of an <code class="docutils literal notranslate"><span class="pre">Index</span></code> or <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code><a class="headerlink" href="#renaming-names-of-an-index-or-multiindex" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">rename()</span></code> method is used to rename the labels of a
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, and is typically used to rename the columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.
The <code class="docutils literal notranslate"><span class="pre">columns</span></code> argument of <code class="docutils literal notranslate"><span class="pre">rename</span></code> allows a dictionary to be specified
that includes only the columns you wish to rename.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [91]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;col0&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;col1&quot;</span><span class="p">})</span>
<span class="gh">Out[91]: </span><span class="go"></span>
<span class="go">            col0      col1</span>
<span class="go">one  y  1.519970 -0.493662</span>
<span class="go">     x  0.600178  0.274230</span>
<span class="go">zero y  0.132885 -0.023688</span>
<span class="go">     x  2.410179  1.450520</span>
</pre></div>
</div>
<p>This method can also be used to rename specific labels of the main index
of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [92]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;one&quot;</span><span class="p">:</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;z&quot;</span><span class="p">})</span>
<span class="gh">Out[92]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">two  z  1.519970 -0.493662</span>
<span class="go">     x  0.600178  0.274230</span>
<span class="go">zero z  0.132885 -0.023688</span>
<span class="go">     x  2.410179  1.450520</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">rename_axis()</span></code> method is used to rename the name of a
<code class="docutils literal notranslate"><span class="pre">Index</span></code> or <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>. In particular, the names of the levels of a
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> can be specified, which is useful if <code class="docutils literal notranslate"><span class="pre">reset_index()</span></code> is later
used to move the values from the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> to a column.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [93]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;def&#39;</span><span class="p">])</span>
<span class="gh">Out[93]: </span><span class="go"></span>
<span class="go">                 0         1</span>
<span class="go">abc  def                    </span>
<span class="go">one  y    1.519970 -0.493662</span>
<span class="go">     x    0.600178  0.274230</span>
<span class="go">zero y    0.132885 -0.023688</span>
<span class="go">     x    2.410179  1.450520</span>
</pre></div>
</div>
<p>Note that the columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> are an index, so that using
<code class="docutils literal notranslate"><span class="pre">rename_axis</span></code> with the <code class="docutils literal notranslate"><span class="pre">columns</span></code> argument will change the name of that
index.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [94]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;Cols&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span>
<span class="gh">Out[94]: </span><span class="go">RangeIndex(start=0, stop=2, step=1, name=&#39;Cols&#39;)</span>
</pre></div>
</div>
<p>Both <code class="docutils literal notranslate"><span class="pre">rename</span></code> and <code class="docutils literal notranslate"><span class="pre">rename_axis</span></code> support specifying a dictionary,
<code class="docutils literal notranslate"><span class="pre">Series</span></code> or a mapping function to map labels/names to new values.</p>
<p>When working with an <code class="docutils literal notranslate"><span class="pre">Index</span></code> object directly, rather than via a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Index.set_names()</span></code> can be used to change the names.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [95]: </span><span class="n">mi</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">])</span>

<span class="gp">In [96]: </span><span class="n">mi</span><span class="o">.</span><span class="n">names</span>
<span class="gh">Out[96]: </span><span class="go">FrozenList([&#39;x&#39;, &#39;y&#39;])</span>

<span class="gp">In [97]: </span><span class="n">mi2</span> <span class="o">=</span> <span class="n">mi</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;new name&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="gp">In [98]: </span><span class="n">mi2</span>
<span class="gh">Out[98]: </span><span class="go"></span>
<span class="go">MultiIndex([(1, &#39;a&#39;),</span>
<span class="go">            (1, &#39;b&#39;),</span>
<span class="go">            (2, &#39;a&#39;),</span>
<span class="go">            (2, &#39;b&#39;)],</span>
<span class="go">           names=[&#39;new name&#39;, &#39;y&#39;])</span>
</pre></div>
</div>
<p>You cannot set the names of the MultiIndex via a level.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [99]: </span><span class="n">mi</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;name via level&quot;</span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">RuntimeError</span><span class="g g-Whitespace">                              </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">99</span><span class="o">-</span><span class="mi">35</span><span class="n">d32a9a5218</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">mi</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;name via level&quot;</span>

<span class="nn">~/scipy/pandas/pandas/core/indexes/base.py</span> in <span class="ni">name</span><span class="nt">(self, value)</span>
<span class="g g-Whitespace">   </span><span class="mi">1168</span>             <span class="c1"># Used in MultiIndex.levels to avoid silently ignoring name updates.</span>
<span class="g g-Whitespace">   </span><span class="mi">1169</span>             <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
<span class="ne">-&gt; </span><span class="mi">1170</span>                 <span class="s2">&quot;Cannot set name on a level of a MultiIndex. Use &quot;</span>
<span class="g g-Whitespace">   </span><span class="mi">1171</span>                 <span class="s2">&quot;&#39;MultiIndex.set_names&#39; instead.&quot;</span>
<span class="g g-Whitespace">   </span><span class="mi">1172</span>             <span class="p">)</span>

<span class="ne">RuntimeError</span>: Cannot set name on a level of a MultiIndex. Use &#39;MultiIndex.set_names&#39; instead.
</pre></div>
</div>
<p>Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Index.set_names()</span></code> instead.</p>
</div>
</div>
<div class="section" id="sorting-a-multiindex">
<h2>Sorting a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code><a class="headerlink" href="#sorting-a-multiindex" title="Permalink to this headline">¶</a></h2>
<p>For <code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code>-ed objects to be indexed and sliced effectively,
they need to be sorted. As with any index, you can use <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_index()</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [100]: </span><span class="kn">import</span> <span class="nn">random</span>

<span class="gp">In [101]: </span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>

<span class="gp">In [102]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">tuples</span><span class="p">))</span>

<span class="gp">In [103]: </span><span class="n">s</span>
<span class="gh">Out[103]: </span><span class="go"></span>
<span class="go">qux  two    0.206053</span>
<span class="go">baz  one   -0.251905</span>
<span class="go">qux  one   -2.213588</span>
<span class="go">foo  two    1.063327</span>
<span class="go">     one    1.266143</span>
<span class="go">baz  two    0.299368</span>
<span class="go">bar  one   -0.863838</span>
<span class="go">     two    0.408204</span>
<span class="go">dtype: float64</span>

<span class="gp">In [104]: </span><span class="n">s</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
<span class="gh">Out[104]: </span><span class="go"></span>
<span class="go">bar  one   -0.863838</span>
<span class="go">     two    0.408204</span>
<span class="go">baz  one   -0.251905</span>
<span class="go">     two    0.299368</span>
<span class="go">foo  one    1.266143</span>
<span class="go">     two    1.063327</span>
<span class="go">qux  one   -2.213588</span>
<span class="go">     two    0.206053</span>
<span class="go">dtype: float64</span>

<span class="gp">In [105]: </span><span class="n">s</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gh">Out[105]: </span><span class="go"></span>
<span class="go">bar  one   -0.863838</span>
<span class="go">     two    0.408204</span>
<span class="go">baz  one   -0.251905</span>
<span class="go">     two    0.299368</span>
<span class="go">foo  one    1.266143</span>
<span class="go">     two    1.063327</span>
<span class="go">qux  one   -2.213588</span>
<span class="go">     two    0.206053</span>
<span class="go">dtype: float64</span>

<span class="gp">In [106]: </span><span class="n">s</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[106]: </span><span class="go"></span>
<span class="go">bar  one   -0.863838</span>
<span class="go">baz  one   -0.251905</span>
<span class="go">foo  one    1.266143</span>
<span class="go">qux  one   -2.213588</span>
<span class="go">bar  two    0.408204</span>
<span class="go">baz  two    0.299368</span>
<span class="go">foo  two    1.063327</span>
<span class="go">qux  two    0.206053</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p id="advanced-sortlevel-byname">You may also pass a level name to <code class="docutils literal notranslate"><span class="pre">sort_index</span></code> if the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> levels
are named.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [107]: </span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">set_names</span><span class="p">([</span><span class="s1">&#39;L1&#39;</span><span class="p">,</span> <span class="s1">&#39;L2&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="gp">In [108]: </span><span class="n">s</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;L1&#39;</span><span class="p">)</span>
<span class="gh">Out[108]: </span><span class="go"></span>
<span class="go">L1   L2 </span>
<span class="go">bar  one   -0.863838</span>
<span class="go">     two    0.408204</span>
<span class="go">baz  one   -0.251905</span>
<span class="go">     two    0.299368</span>
<span class="go">foo  one    1.266143</span>
<span class="go">     two    1.063327</span>
<span class="go">qux  one   -2.213588</span>
<span class="go">     two    0.206053</span>
<span class="go">dtype: float64</span>

<span class="gp">In [109]: </span><span class="n">s</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">)</span>
<span class="gh">Out[109]: </span><span class="go"></span>
<span class="go">L1   L2 </span>
<span class="go">bar  one   -0.863838</span>
<span class="go">baz  one   -0.251905</span>
<span class="go">foo  one    1.266143</span>
<span class="go">qux  one   -2.213588</span>
<span class="go">bar  two    0.408204</span>
<span class="go">baz  two    0.299368</span>
<span class="go">foo  two    1.063327</span>
<span class="go">qux  two    0.206053</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>On higher dimensional objects, you can sort any of the other axes by level if
they have a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [110]: </span><span class="n">df</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[110]: </span><span class="go"></span>
<span class="go">        one      zero       one      zero</span>
<span class="go">          x         x         y         y</span>
<span class="go">0  0.600178  2.410179  1.519970  0.132885</span>
<span class="go">1  0.274230  1.450520 -0.493662 -0.023688</span>
</pre></div>
</div>
<p>Indexing will work even if the data are not sorted, but will be rather
inefficient (and show a <code class="docutils literal notranslate"><span class="pre">PerformanceWarning</span></code>). It will also
return a copy of the data rather than a view:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [111]: </span><span class="n">dfm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;jim&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;joe&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;jolie&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">)})</span>
<span class="gp">   .....: </span>

<span class="gp">In [112]: </span><span class="n">dfm</span> <span class="o">=</span> <span class="n">dfm</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;jim&#39;</span><span class="p">,</span> <span class="s1">&#39;joe&#39;</span><span class="p">])</span>

<span class="gp">In [113]: </span><span class="n">dfm</span>
<span class="gh">Out[113]: </span><span class="go"></span>
<span class="go">            jolie</span>
<span class="go">jim joe          </span>
<span class="go">0   x    0.490671</span>
<span class="go">    x    0.120248</span>
<span class="go">1   z    0.537020</span>
<span class="go">    y    0.110968</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)]</span>
<span class="go">PerformanceWarning: indexing past lexsort depth may impact performance.</span>

<span class="gh">Out[4]:</span>
<span class="go">           jolie</span>
<span class="go">jim joe</span>
<span class="go">1   z    0.64094</span>
</pre></div>
</div>
<p id="advanced-unsorted">Furthermore, if you try to index something that is not fully lexsorted, this can raise:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">):(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)]</span>
<span class="go">UnsortedIndexError: &#39;Key length (2) was greater than MultiIndex lexsort depth (1)&#39;</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lexsorted()</span></code> method on a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> shows if the
index is sorted, and the <code class="docutils literal notranslate"><span class="pre">lexsort_depth</span></code> property returns the sort depth:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [114]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_lexsorted</span><span class="p">()</span>
<span class="gh">Out[114]: </span><span class="go">False</span>

<span class="gp">In [115]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">lexsort_depth</span>
<span class="gh">Out[115]: </span><span class="go">1</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [116]: </span><span class="n">dfm</span> <span class="o">=</span> <span class="n">dfm</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

<span class="gp">In [117]: </span><span class="n">dfm</span>
<span class="gh">Out[117]: </span><span class="go"></span>
<span class="go">            jolie</span>
<span class="go">jim joe          </span>
<span class="go">0   x    0.490671</span>
<span class="go">    x    0.120248</span>
<span class="go">1   y    0.110968</span>
<span class="go">    z    0.537020</span>

<span class="gp">In [118]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_lexsorted</span><span class="p">()</span>
<span class="gh">Out[118]: </span><span class="go">True</span>

<span class="gp">In [119]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">lexsort_depth</span>
<span class="gh">Out[119]: </span><span class="go">2</span>
</pre></div>
</div>
<p>And now selection works as expected.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [120]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">):(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)]</span>
<span class="gh">Out[120]: </span><span class="go"></span>
<span class="go">            jolie</span>
<span class="go">jim joe          </span>
<span class="go">1   y    0.110968</span>
<span class="go">    z    0.537020</span>
</pre></div>
</div>
</div>
<div class="section" id="take-methods">
<h2>Take methods<a class="headerlink" href="#take-methods" title="Permalink to this headline">¶</a></h2>
<p id="advanced-take">Similar to NumPy ndarrays, pandas <code class="docutils literal notranslate"><span class="pre">Index</span></code>, <code class="docutils literal notranslate"><span class="pre">Series</span></code>, and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> also provides
the <code class="xref py py-meth docutils literal notranslate"><span class="pre">take()</span></code> method that retrieves elements along a given axis at the given
indices. The given indices must be either a list or an ndarray of integer
index positions. <code class="docutils literal notranslate"><span class="pre">take</span></code> will also accept negative integers as relative positions to the end of the object.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [121]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="gp">In [122]: </span><span class="n">index</span>
<span class="gh">Out[122]: </span><span class="go">Int64Index([214, 502, 712, 567, 786, 175, 993, 133, 758, 329], dtype=&#39;int64&#39;)</span>

<span class="gp">In [123]: </span><span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">In [124]: </span><span class="n">index</span><span class="p">[</span><span class="n">positions</span><span class="p">]</span>
<span class="gh">Out[124]: </span><span class="go">Int64Index([214, 329, 567], dtype=&#39;int64&#39;)</span>

<span class="gp">In [125]: </span><span class="n">index</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
<span class="gh">Out[125]: </span><span class="go">Int64Index([214, 329, 567], dtype=&#39;int64&#39;)</span>

<span class="gp">In [126]: </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="gp">In [127]: </span><span class="n">ser</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">positions</span><span class="p">]</span>
<span class="gh">Out[127]: </span><span class="go"></span>
<span class="go">0   -0.179666</span>
<span class="go">9    1.824375</span>
<span class="go">3    0.392149</span>
<span class="go">dtype: float64</span>

<span class="gp">In [128]: </span><span class="n">ser</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
<span class="gh">Out[128]: </span><span class="go"></span>
<span class="go">0   -0.179666</span>
<span class="go">9    1.824375</span>
<span class="go">3    0.392149</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>For DataFrames, the given indices should be a 1d list or ndarray that specifies
row or column positions.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [129]: </span><span class="n">frm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="gp">In [130]: </span><span class="n">frm</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gh">Out[130]: </span><span class="go"></span>
<span class="go">          0         1         2</span>
<span class="go">1 -1.237881  0.106854 -1.276829</span>
<span class="go">4  0.629675 -1.425966  1.857704</span>
<span class="go">3  0.979542 -1.633678  0.615855</span>

<span class="gp">In [131]: </span><span class="n">frm</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[131]: </span><span class="go"></span>
<span class="go">          0         2</span>
<span class="go">0  0.595974  0.601544</span>
<span class="go">1 -1.237881 -1.276829</span>
<span class="go">2 -0.767101  1.499591</span>
<span class="go">3  0.979542  0.615855</span>
<span class="go">4  0.629675  1.857704</span>
</pre></div>
</div>
<p>It is important to note that the <code class="docutils literal notranslate"><span class="pre">take</span></code> method on pandas objects are not
intended to work on boolean indices and may return unexpected results.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [132]: </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="gp">In [133]: </span><span class="n">arr</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span>
<span class="gh">Out[133]: </span><span class="go">array([-1.1935, -1.1935,  0.6775,  0.6775])</span>

<span class="gp">In [134]: </span><span class="n">arr</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gh">Out[134]: </span><span class="go">array([-1.1935,  0.6775])</span>

<span class="gp">In [135]: </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="gp">In [136]: </span><span class="n">ser</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span>
<span class="gh">Out[136]: </span><span class="go"></span>
<span class="go">0    0.233141</span>
<span class="go">0    0.233141</span>
<span class="go">1   -0.223540</span>
<span class="go">1   -0.223540</span>
<span class="go">dtype: float64</span>

<span class="gp">In [137]: </span><span class="n">ser</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gh">Out[137]: </span><span class="go"></span>
<span class="go">0    0.233141</span>
<span class="go">1   -0.223540</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Finally, as a small note on performance, because the <code class="docutils literal notranslate"><span class="pre">take</span></code> method handles
a narrower range of inputs, it can offer performance that is a good deal
faster than fancy indexing.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [138]: </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="gp">In [139]: </span><span class="n">indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

<span class="gp">In [140]: </span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

<span class="gp">In [141]: </span><span class="o">%</span><span class="k">timeit</span> arr[indexer]
<span class="gp">   .....: </span><span class="o">%</span><span class="k">timeit</span> arr.take(indexer, axis=0)
<span class="gp">   .....: </span>
<span class="go">160 us +- 11.8 us per loop (mean +- std. dev. of 7 runs, 10000 loops each)</span>
<span class="go">59.3 us +- 5.1 us per loop (mean +- std. dev. of 7 runs, 10000 loops each)</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [142]: </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

<span class="gp">In [143]: </span><span class="o">%</span><span class="k">timeit</span> ser.iloc[indexer]
<span class="gp">   .....: </span><span class="o">%</span><span class="k">timeit</span> ser.take(indexer)
<span class="gp">   .....: </span>
<span class="go">142 us +- 12.9 us per loop (mean +- std. dev. of 7 runs, 10000 loops each)</span>
<span class="go">120 us +- 8.9 us per loop (mean +- std. dev. of 7 runs, 10000 loops each)</span>
</pre></div>
</div>
</div>
<div class="section" id="index-types">
<span id="indexing-index-types"></span><h2>Index types<a class="headerlink" href="#index-types" title="Permalink to this headline">¶</a></h2>
<p>We have discussed <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> in the previous sections pretty extensively.
Documentation about <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> and <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> are shown <a class="reference internal" href="timeseries.html#timeseries-overview"><span class="std std-ref">here</span></a>,
and documentation about <code class="docutils literal notranslate"><span class="pre">TimedeltaIndex</span></code> is found <a class="reference internal" href="timedeltas.html#timedeltas-index"><span class="std std-ref">here</span></a>.</p>
<p>In the following sub-sections we will highlight some other index types.</p>
<div class="section" id="categoricalindex">
<span id="indexing-categoricalindex"></span><h3>CategoricalIndex<a class="headerlink" href="#categoricalindex" title="Permalink to this headline">¶</a></h3>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalIndex</span></code> is a type of index that is useful for supporting
indexing with duplicates. This is a container around a <code class="xref py py-class docutils literal notranslate"><span class="pre">Categorical</span></code>
and allows efficient indexing and storage of an index with a large number of duplicated elements.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [144]: </span><span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">CategoricalDtype</span>

<span class="gp">In [145]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
<span class="gp">   .....: </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;aabbca&#39;</span><span class="p">)})</span>
<span class="gp">   .....: </span>

<span class="gp">In [146]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">CategoricalDtype</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;cab&#39;</span><span class="p">)))</span>

<span class="gp">In [147]: </span><span class="n">df</span>
<span class="gh">Out[147]: </span><span class="go"></span>
<span class="go">   A  B</span>
<span class="go">0  0  a</span>
<span class="go">1  1  a</span>
<span class="go">2  2  b</span>
<span class="go">3  3  b</span>
<span class="go">4  4  c</span>
<span class="go">5  5  a</span>

<span class="gp">In [148]: </span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span>
<span class="gh">Out[148]: </span><span class="go"></span>
<span class="go">A       int64</span>
<span class="go">B    category</span>
<span class="go">dtype: object</span>

<span class="gp">In [149]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span>
<span class="gh">Out[149]: </span><span class="go">Index([&#39;c&#39;, &#39;a&#39;, &#39;b&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<p>Setting the index will create a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [150]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">In [151]: </span><span class="n">df2</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[151]: </span><span class="go">CategoricalIndex([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;], categories=[&#39;c&#39;, &#39;a&#39;, &#39;b&#39;], ordered=False, name=&#39;B&#39;, dtype=&#39;category&#39;)</span>
</pre></div>
</div>
<p>Indexing with <code class="docutils literal notranslate"><span class="pre">__getitem__/.iloc/.loc</span></code> works similarly to an <code class="docutils literal notranslate"><span class="pre">Index</span></code> with duplicates.
The indexers <strong>must</strong> be in the category or the operation will raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [152]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gh">Out[152]: </span><span class="go"></span>
<span class="go">   A</span>
<span class="go">B   </span>
<span class="go">a  0</span>
<span class="go">a  1</span>
<span class="go">a  5</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code> is <strong>preserved</strong> after indexing:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [153]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[153]: </span><span class="go">CategoricalIndex([&#39;a&#39;, &#39;a&#39;, &#39;a&#39;], categories=[&#39;c&#39;, &#39;a&#39;, &#39;b&#39;], ordered=False, name=&#39;B&#39;, dtype=&#39;category&#39;)</span>
</pre></div>
</div>
<p>Sorting the index will sort by the order of the categories (recall that we
created the index with <code class="docutils literal notranslate"><span class="pre">CategoricalDtype(list('cab'))</span></code>, so the sorted
order is <code class="docutils literal notranslate"><span class="pre">cab</span></code>).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [154]: </span><span class="n">df2</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
<span class="gh">Out[154]: </span><span class="go"></span>
<span class="go">   A</span>
<span class="go">B   </span>
<span class="go">c  4</span>
<span class="go">a  0</span>
<span class="go">a  1</span>
<span class="go">a  5</span>
<span class="go">b  2</span>
<span class="go">b  3</span>
</pre></div>
</div>
<p>Groupby operations on the index will preserve the index nature as well.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [155]: </span><span class="n">df2</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[155]: </span><span class="go"></span>
<span class="go">   A</span>
<span class="go">B   </span>
<span class="go">c  4</span>
<span class="go">a  6</span>
<span class="go">b  5</span>

<span class="gp">In [156]: </span><span class="n">df2</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[156]: </span><span class="go">CategoricalIndex([&#39;c&#39;, &#39;a&#39;, &#39;b&#39;], categories=[&#39;c&#39;, &#39;a&#39;, &#39;b&#39;], ordered=False, name=&#39;B&#39;, dtype=&#39;category&#39;)</span>
</pre></div>
</div>
<p>Reindexing operations will return a resulting index based on the type of the passed
indexer. Passing a list will return a plain-old <code class="docutils literal notranslate"><span class="pre">Index</span></code>; indexing with
a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> will return a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code>, indexed according to the categories
of the <strong>passed</strong> <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> dtype. This allows one to arbitrarily index these even with
values <strong>not</strong> in the categories, similarly to how you can reindex <strong>any</strong> pandas index.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [157]: </span><span class="n">df3</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)})</span>
<span class="gp">   .....: </span>

<span class="gp">In [158]: </span><span class="n">df3</span> <span class="o">=</span> <span class="n">df3</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">In [159]: </span><span class="n">df3</span>
<span class="gh">Out[159]: </span><span class="go"></span>
<span class="go">   A</span>
<span class="go">B   </span>
<span class="go">a  0</span>
<span class="go">b  1</span>
<span class="go">c  2</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [160]: </span><span class="n">df3</span><span class="o">.</span><span class="n">reindex</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>
<span class="gh">Out[160]: </span><span class="go"></span>
<span class="go">     A</span>
<span class="go">B     </span>
<span class="go">a  0.0</span>
<span class="go">e  NaN</span>

<span class="gp">In [161]: </span><span class="n">df3</span><span class="o">.</span><span class="n">reindex</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[161]: </span><span class="go">Index([&#39;a&#39;, &#39;e&#39;], dtype=&#39;object&#39;, name=&#39;B&#39;)</span>

<span class="gp">In [162]: </span><span class="n">df3</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">],</span> <span class="n">categories</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abe&#39;</span><span class="p">)))</span>
<span class="gh">Out[162]: </span><span class="go"></span>
<span class="go">     A</span>
<span class="go">B     </span>
<span class="go">a  0.0</span>
<span class="go">e  NaN</span>

<span class="gp">In [163]: </span><span class="n">df3</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">],</span> <span class="n">categories</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abe&#39;</span><span class="p">)))</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[163]: </span><span class="go">CategoricalIndex([&#39;a&#39;, &#39;e&#39;], categories=[&#39;a&#39;, &#39;b&#39;, &#39;e&#39;], ordered=False, name=&#39;B&#39;, dtype=&#39;category&#39;)</span>
</pre></div>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Reshaping and Comparison operations on a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code> must have the same categories
or a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> will be raised.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [164]: </span><span class="n">df4</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;ba&#39;</span><span class="p">)})</span>
<span class="gp">   .....: </span>

<span class="gp">In [165]: </span><span class="n">df4</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df4</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">CategoricalDtype</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">)))</span>

<span class="gp">In [166]: </span><span class="n">df4</span> <span class="o">=</span> <span class="n">df4</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">In [167]: </span><span class="n">df4</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[167]: </span><span class="go">CategoricalIndex([&#39;b&#39;, &#39;a&#39;], categories=[&#39;a&#39;, &#39;b&#39;], ordered=False, name=&#39;B&#39;, dtype=&#39;category&#39;)</span>

<span class="gp">In [168]: </span><span class="n">df5</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;bc&#39;</span><span class="p">)})</span>
<span class="gp">   .....: </span>

<span class="gp">In [169]: </span><span class="n">df5</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df5</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">CategoricalDtype</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;bc&#39;</span><span class="p">)))</span>

<span class="gp">In [170]: </span><span class="n">df5</span> <span class="o">=</span> <span class="n">df5</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">In [171]: </span><span class="n">df5</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[171]: </span><span class="go">CategoricalIndex([&#39;b&#39;, &#39;c&#39;], categories=[&#39;b&#39;, &#39;c&#39;], ordered=False, name=&#39;B&#39;, dtype=&#39;category&#39;)</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df4</span><span class="p">,</span> <span class="n">df5</span><span class="p">])</span>
<span class="go">TypeError: categories must match existing categories when appending</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="int64index-and-rangeindex">
<span id="indexing-rangeindex"></span><h3>Int64Index and RangeIndex<a class="headerlink" href="#int64index-and-rangeindex" title="Permalink to this headline">¶</a></h3>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Int64Index</span></code> is a fundamental basic index in pandas. This is an immutable array
implementing an ordered, sliceable set.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">RangeIndex</span></code> is a sub-class of <code class="docutils literal notranslate"><span class="pre">Int64Index</span></code>  that provides the default index for all <code class="docutils literal notranslate"><span class="pre">NDFrame</span></code> objects.
<code class="docutils literal notranslate"><span class="pre">RangeIndex</span></code> is an optimized version of <code class="docutils literal notranslate"><span class="pre">Int64Index</span></code> that can represent a monotonic ordered set. These are analogous to Python <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#typesseq-range">range types</a>.</p>
</div>
<div class="section" id="float64index">
<span id="indexing-float64index"></span><h3>Float64Index<a class="headerlink" href="#float64index" title="Permalink to this headline">¶</a></h3>
<p>By default a <code class="xref py py-class docutils literal notranslate"><span class="pre">Float64Index</span></code> will be automatically created when passing floating, or mixed-integer-floating values in index creation.
This enables a pure label-based slicing paradigm that makes <code class="docutils literal notranslate"><span class="pre">[],ix,loc</span></code> for scalar indexing and slicing work exactly the
same.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [172]: </span><span class="n">indexf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="gp">In [173]: </span><span class="n">indexf</span>
<span class="gh">Out[173]: </span><span class="go">Float64Index([1.5, 2.0, 3.0, 4.5, 5.0], dtype=&#39;float64&#39;)</span>

<span class="gp">In [174]: </span><span class="n">sf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">indexf</span><span class="p">)</span>

<span class="gp">In [175]: </span><span class="n">sf</span>
<span class="gh">Out[175]: </span><span class="go"></span>
<span class="go">1.5    0</span>
<span class="go">2.0    1</span>
<span class="go">3.0    2</span>
<span class="go">4.5    3</span>
<span class="go">5.0    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Scalar selection for <code class="docutils literal notranslate"><span class="pre">[],.loc</span></code> will always be label based. An integer will match an equal float index (e.g. <code class="docutils literal notranslate"><span class="pre">3</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">3.0</span></code>).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [176]: </span><span class="n">sf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gh">Out[176]: </span><span class="go">2</span>

<span class="gp">In [177]: </span><span class="n">sf</span><span class="p">[</span><span class="mf">3.0</span><span class="p">]</span>
<span class="gh">Out[177]: </span><span class="go">2</span>

<span class="gp">In [178]: </span><span class="n">sf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gh">Out[178]: </span><span class="go">2</span>

<span class="gp">In [179]: </span><span class="n">sf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mf">3.0</span><span class="p">]</span>
<span class="gh">Out[179]: </span><span class="go">2</span>
</pre></div>
</div>
<p>The only positional indexing is via <code class="docutils literal notranslate"><span class="pre">iloc</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [180]: </span><span class="n">sf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gh">Out[180]: </span><span class="go">3</span>
</pre></div>
</div>
<p>A scalar index that is not found will raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.
Slicing is primarily on the values of the index when using <code class="docutils literal notranslate"><span class="pre">[],ix,loc</span></code>, and
<strong>always</strong> positional when using <code class="docutils literal notranslate"><span class="pre">iloc</span></code>. The exception is when the slice is
boolean, in which case it will always be positional.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [181]: </span><span class="n">sf</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gh">Out[181]: </span><span class="go"></span>
<span class="go">2.0    1</span>
<span class="go">3.0    2</span>
<span class="go">dtype: int64</span>

<span class="gp">In [182]: </span><span class="n">sf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gh">Out[182]: </span><span class="go"></span>
<span class="go">2.0    1</span>
<span class="go">3.0    2</span>
<span class="go">dtype: int64</span>

<span class="gp">In [183]: </span><span class="n">sf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gh">Out[183]: </span><span class="go"></span>
<span class="go">3.0    2</span>
<span class="go">4.5    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>In float indexes, slicing using floats is allowed.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [184]: </span><span class="n">sf</span><span class="p">[</span><span class="mf">2.1</span><span class="p">:</span><span class="mf">4.6</span><span class="p">]</span>
<span class="gh">Out[184]: </span><span class="go"></span>
<span class="go">3.0    2</span>
<span class="go">4.5    3</span>
<span class="go">dtype: int64</span>

<span class="gp">In [185]: </span><span class="n">sf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mf">2.1</span><span class="p">:</span><span class="mf">4.6</span><span class="p">]</span>
<span class="gh">Out[185]: </span><span class="go"></span>
<span class="go">3.0    2</span>
<span class="go">4.5    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>In non-float indexes, slicing using floats will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mf">3.5</span><span class="p">]</span>
<span class="go">TypeError: the label [3.5] is not a proper indexer for this index type (Int64Index)</span>

<span class="gp">In [1]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mf">3.5</span><span class="p">:</span><span class="mf">4.5</span><span class="p">]</span>
<span class="go">TypeError: the slice start [3.5] is not a proper indexer for this index type (Int64Index)</span>
</pre></div>
</div>
<p>Here is a typical use-case for using this type of indexing. Imagine that you have a somewhat
irregular timedelta-like indexing scheme, but the data is recorded as floats. This could, for
example, be millisecond offsets.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [186]: </span><span class="n">dfir</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">   .....: </span>                               <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">250.0</span><span class="p">,</span>
<span class="gp">   .....: </span>                               <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">)),</span>
<span class="gp">   .....: </span>                  <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">   .....: </span>                               <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mf">250.1</span><span class="p">,</span>
<span class="gp">   .....: </span>                               <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))])</span>
<span class="gp">   .....: </span>

<span class="gp">In [187]: </span><span class="n">dfir</span>
<span class="gh">Out[187]: </span><span class="go"></span>
<span class="go">               A         B</span>
<span class="go">0.0    -0.435772 -1.188928</span>
<span class="go">250.0  -0.808286 -0.284634</span>
<span class="go">500.0  -1.815703  1.347213</span>
<span class="go">750.0  -0.243487  0.514704</span>
<span class="go">1000.0  1.162969 -0.287725</span>
<span class="go">1000.4 -0.179734  0.993962</span>
<span class="go">1250.5 -0.212673  0.909872</span>
<span class="go">1500.6 -0.733333 -0.349893</span>
<span class="go">1750.7  0.456434 -0.306735</span>
<span class="go">2000.8  0.553396  0.166221</span>
<span class="go">2250.9 -0.101684 -0.734907</span>
</pre></div>
</div>
<p>Selection operations then will always work on a value basis, for all selection operators.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [188]: </span><span class="n">dfir</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mf">1000.4</span><span class="p">]</span>
<span class="gh">Out[188]: </span><span class="go"></span>
<span class="go">               A         B</span>
<span class="go">0.0    -0.435772 -1.188928</span>
<span class="go">250.0  -0.808286 -0.284634</span>
<span class="go">500.0  -1.815703  1.347213</span>
<span class="go">750.0  -0.243487  0.514704</span>
<span class="go">1000.0  1.162969 -0.287725</span>
<span class="go">1000.4 -0.179734  0.993962</span>

<span class="gp">In [189]: </span><span class="n">dfir</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1001</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gh">Out[189]: </span><span class="go"></span>
<span class="go">0.0      -0.435772</span>
<span class="go">250.0    -0.808286</span>
<span class="go">500.0    -1.815703</span>
<span class="go">750.0    -0.243487</span>
<span class="go">1000.0    1.162969</span>
<span class="go">1000.4   -0.179734</span>
<span class="go">Name: A, dtype: float64</span>

<span class="gp">In [190]: </span><span class="n">dfir</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mf">1000.4</span><span class="p">]</span>
<span class="gh">Out[190]: </span><span class="go"></span>
<span class="go">A   -0.179734</span>
<span class="go">B    0.993962</span>
<span class="go">Name: 1000.4, dtype: float64</span>
</pre></div>
</div>
<p>You could retrieve the first 1 second (1000 ms) of data as such:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [191]: </span><span class="n">dfir</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
<span class="gh">Out[191]: </span><span class="go"></span>
<span class="go">               A         B</span>
<span class="go">0.0    -0.435772 -1.188928</span>
<span class="go">250.0  -0.808286 -0.284634</span>
<span class="go">500.0  -1.815703  1.347213</span>
<span class="go">750.0  -0.243487  0.514704</span>
<span class="go">1000.0  1.162969 -0.287725</span>
</pre></div>
</div>
<p>If you need integer based selection, you should use <code class="docutils literal notranslate"><span class="pre">iloc</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [192]: </span><span class="n">dfir</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="gh">Out[192]: </span><span class="go"></span>
<span class="go">               A         B</span>
<span class="go">0.0    -0.435772 -1.188928</span>
<span class="go">250.0  -0.808286 -0.284634</span>
<span class="go">500.0  -1.815703  1.347213</span>
<span class="go">750.0  -0.243487  0.514704</span>
<span class="go">1000.0  1.162969 -0.287725</span>
</pre></div>
</div>
</div>
<div class="section" id="intervalindex">
<span id="advanced-intervalindex"></span><h3>IntervalIndex<a class="headerlink" href="#intervalindex" title="Permalink to this headline">¶</a></h3>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">IntervalIndex</span></code> together with its own dtype, <code class="xref py py-class docutils literal notranslate"><span class="pre">IntervalDtype</span></code>
as well as the <code class="xref py py-class docutils literal notranslate"><span class="pre">Interval</span></code> scalar type,  allow first-class support in pandas
for interval notation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> allows some unique indexing and is also used as a
return type for the categories in <code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">qcut()</span></code>.</p>
<div class="section" id="indexing-with-an-intervalindex">
<h4>Indexing with an <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code><a class="headerlink" href="#indexing-with-an-intervalindex" title="Permalink to this headline">¶</a></h4>
<p>An <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> can be used in <code class="docutils literal notranslate"><span class="pre">Series</span></code> and in <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> as the index.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [193]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>
<span class="gp">   .....: </span>                  <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">IntervalIndex</span><span class="o">.</span><span class="n">from_breaks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="gp">   .....: </span>

<span class="gp">In [194]: </span><span class="n">df</span>
<span class="gh">Out[194]: </span><span class="go"></span>
<span class="go">        A</span>
<span class="go">(0, 1]  1</span>
<span class="go">(1, 2]  2</span>
<span class="go">(2, 3]  3</span>
<span class="go">(3, 4]  4</span>
</pre></div>
</div>
<p>Label based indexing via <code class="docutils literal notranslate"><span class="pre">.loc</span></code> along the edges of an interval works as you would expect,
selecting that particular interval.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [195]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gh">Out[195]: </span><span class="go"></span>
<span class="go">A    2</span>
<span class="go">Name: (1, 2], dtype: int64</span>

<span class="gp">In [196]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gh">Out[196]: </span><span class="go"></span>
<span class="go">        A</span>
<span class="go">(1, 2]  2</span>
<span class="go">(2, 3]  3</span>
</pre></div>
</div>
<p>If you select a label <em>contained</em> within an interval, this will also select the interval.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [197]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mf">2.5</span><span class="p">]</span>
<span class="gh">Out[197]: </span><span class="go"></span>
<span class="go">A    3</span>
<span class="go">Name: (2, 3], dtype: int64</span>

<span class="gp">In [198]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]]</span>
<span class="gh">Out[198]: </span><span class="go"></span>
<span class="go">        A</span>
<span class="go">(2, 3]  3</span>
<span class="go">(3, 4]  4</span>
</pre></div>
</div>
<p>Selecting using an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> will only return exact matches (starting from pandas 0.25.0).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [199]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="gh">Out[199]: </span><span class="go"></span>
<span class="go">A    2</span>
<span class="go">Name: (1, 2], dtype: int64</span>
</pre></div>
</div>
<p>Trying to select an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that is not exactly contained in the <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> will raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">7</span><span class="p">]:</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)]</span>
<span class="o">---------------------------------------------------------------------------</span>
<span class="ne">KeyError</span><span class="p">:</span> <span class="n">Interval</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Selecting all <code class="docutils literal notranslate"><span class="pre">Intervals</span></code> that overlap a given <code class="docutils literal notranslate"><span class="pre">Interval</span></code> can be performed using the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">overlaps()</span></code> method to create a boolean indexer.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [200]: </span><span class="n">idxr</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">overlaps</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">))</span>

<span class="gp">In [201]: </span><span class="n">idxr</span>
<span class="gh">Out[201]: </span><span class="go">array([ True,  True,  True, False])</span>

<span class="gp">In [202]: </span><span class="n">df</span><span class="p">[</span><span class="n">idxr</span><span class="p">]</span>
<span class="gh">Out[202]: </span><span class="go"></span>
<span class="go">        A</span>
<span class="go">(0, 1]  1</span>
<span class="go">(1, 2]  2</span>
<span class="go">(2, 3]  3</span>
</pre></div>
</div>
</div>
<div class="section" id="binning-data-with-cut-and-qcut">
<h4>Binning data with <code class="docutils literal notranslate"><span class="pre">cut</span></code> and <code class="docutils literal notranslate"><span class="pre">qcut</span></code><a class="headerlink" href="#binning-data-with-cut-and-qcut" title="Permalink to this headline">¶</a></h4>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">qcut()</span></code> both return a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> object, and the bins they
create are stored as an <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> in its <code class="docutils literal notranslate"><span class="pre">.categories</span></code> attribute.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [203]: </span><span class="n">c</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [204]: </span><span class="n">c</span>
<span class="gh">Out[204]: </span><span class="go"></span>
<span class="go">[(-0.003, 1.5], (-0.003, 1.5], (1.5, 3.0], (1.5, 3.0]]</span>
<span class="go">Categories (2, interval[float64]): [(-0.003, 1.5] &lt; (1.5, 3.0]]</span>

<span class="gp">In [205]: </span><span class="n">c</span><span class="o">.</span><span class="n">categories</span>
<span class="gh">Out[205]: </span><span class="go"></span>
<span class="go">IntervalIndex([(-0.003, 1.5], (1.5, 3.0]],</span>
<span class="go">              closed=&#39;right&#39;,</span>
<span class="go">              dtype=&#39;interval[float64]&#39;)</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code> also accepts an <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> for its <code class="docutils literal notranslate"><span class="pre">bins</span></code> argument, which enables
a useful pandas idiom. First, We call <code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code> with some data and <code class="docutils literal notranslate"><span class="pre">bins</span></code> set to a
fixed number, to generate the bins. Then, we pass the values of <code class="docutils literal notranslate"><span class="pre">.categories</span></code> as the
<code class="docutils literal notranslate"><span class="pre">bins</span></code> argument in subsequent calls to <code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code>, supplying new data which will be
binned into the same bins.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [206]: </span><span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
<span class="gh">Out[206]: </span><span class="go"></span>
<span class="go">[(-0.003, 1.5], (1.5, 3.0], NaN, (-0.003, 1.5]]</span>
<span class="go">Categories (2, interval[float64]): [(-0.003, 1.5] &lt; (1.5, 3.0]]</span>
</pre></div>
</div>
<p>Any value which falls outside all bins will be assigned a <code class="docutils literal notranslate"><span class="pre">NaN</span></code> value.</p>
</div>
<div class="section" id="generating-ranges-of-intervals">
<h4>Generating ranges of intervals<a class="headerlink" href="#generating-ranges-of-intervals" title="Permalink to this headline">¶</a></h4>
<p>If we need intervals on a regular frequency, we can use the <code class="xref py py-func docutils literal notranslate"><span class="pre">interval_range()</span></code> function
to create an <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> using various combinations of <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">periods</span></code>.
The default frequency for <code class="docutils literal notranslate"><span class="pre">interval_range</span></code> is a 1 for numeric intervals, and calendar day for
datetime-like intervals:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [207]: </span><span class="n">pd</span><span class="o">.</span><span class="n">interval_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gh">Out[207]: </span><span class="go"></span>
<span class="go">IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],</span>
<span class="go">              closed=&#39;right&#39;,</span>
<span class="go">              dtype=&#39;interval[int64]&#39;)</span>

<span class="gp">In [208]: </span><span class="n">pd</span><span class="o">.</span><span class="n">interval_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;2017-01-01&#39;</span><span class="p">),</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gh">Out[208]: </span><span class="go"></span>
<span class="go">IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04], (2017-01-04, 2017-01-05]],</span>
<span class="go">              closed=&#39;right&#39;,</span>
<span class="go">              dtype=&#39;interval[datetime64[ns]]&#39;)</span>

<span class="gp">In [209]: </span><span class="n">pd</span><span class="o">.</span><span class="n">interval_range</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;3 days&#39;</span><span class="p">),</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gh">Out[209]: </span><span class="go"></span>
<span class="go">IntervalIndex([(0 days 00:00:00, 1 days 00:00:00], (1 days 00:00:00, 2 days 00:00:00], (2 days 00:00:00, 3 days 00:00:00]],</span>
<span class="go">              closed=&#39;right&#39;,</span>
<span class="go">              dtype=&#39;interval[timedelta64[ns]]&#39;)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">freq</span></code> parameter can used to specify non-default frequencies, and can utilize a variety
of <a class="reference internal" href="timeseries.html#timeseries-offset-aliases"><span class="std std-ref">frequency aliases</span></a> with datetime-like intervals:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [210]: </span><span class="n">pd</span><span class="o">.</span><span class="n">interval_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gh">Out[210]: </span><span class="go"></span>
<span class="go">IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0], (6.0, 7.5]],</span>
<span class="go">              closed=&#39;right&#39;,</span>
<span class="go">              dtype=&#39;interval[float64]&#39;)</span>

<span class="gp">In [211]: </span><span class="n">pd</span><span class="o">.</span><span class="n">interval_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;2017-01-01&#39;</span><span class="p">),</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
<span class="gh">Out[211]: </span><span class="go"></span>
<span class="go">IntervalIndex([(2017-01-01, 2017-01-08], (2017-01-08, 2017-01-15], (2017-01-15, 2017-01-22], (2017-01-22, 2017-01-29]],</span>
<span class="go">              closed=&#39;right&#39;,</span>
<span class="go">              dtype=&#39;interval[datetime64[ns]]&#39;)</span>

<span class="gp">In [212]: </span><span class="n">pd</span><span class="o">.</span><span class="n">interval_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;0 days&#39;</span><span class="p">),</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;9H&#39;</span><span class="p">)</span>
<span class="gh">Out[212]: </span><span class="go"></span>
<span class="go">IntervalIndex([(0 days 00:00:00, 0 days 09:00:00], (0 days 09:00:00, 0 days 18:00:00], (0 days 18:00:00, 1 days 03:00:00]],</span>
<span class="go">              closed=&#39;right&#39;,</span>
<span class="go">              dtype=&#39;interval[timedelta64[ns]]&#39;)</span>
</pre></div>
</div>
<p>Additionally, the <code class="docutils literal notranslate"><span class="pre">closed</span></code> parameter can be used to specify which side(s) the intervals
are closed on.  Intervals are closed on the right side by default.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [213]: </span><span class="n">pd</span><span class="o">.</span><span class="n">interval_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
<span class="gh">Out[213]: </span><span class="go"></span>
<span class="go">IntervalIndex([[0, 1], [1, 2], [2, 3], [3, 4]],</span>
<span class="go">              closed=&#39;both&#39;,</span>
<span class="go">              dtype=&#39;interval[int64]&#39;)</span>

<span class="gp">In [214]: </span><span class="n">pd</span><span class="o">.</span><span class="n">interval_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s1">&#39;neither&#39;</span><span class="p">)</span>
<span class="gh">Out[214]: </span><span class="go"></span>
<span class="go">IntervalIndex([(0, 1), (1, 2), (2, 3), (3, 4)],</span>
<span class="go">              closed=&#39;neither&#39;,</span>
<span class="go">              dtype=&#39;interval[int64]&#39;)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.23.0.</span></p>
</div>
<p>Specifying <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">periods</span></code> will generate a range of evenly spaced
intervals from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">end</span></code> inclusively, with <code class="docutils literal notranslate"><span class="pre">periods</span></code> number of elements
in the resulting <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [215]: </span><span class="n">pd</span><span class="o">.</span><span class="n">interval_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gh">Out[215]: </span><span class="go"></span>
<span class="go">IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],</span>
<span class="go">              closed=&#39;right&#39;,</span>
<span class="go">              dtype=&#39;interval[float64]&#39;)</span>

<span class="gp">In [216]: </span><span class="n">pd</span><span class="o">.</span><span class="n">interval_range</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;2018-01-01&#39;</span><span class="p">),</span>
<span class="gp">   .....: </span>                  <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;2018-02-28&#39;</span><span class="p">),</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">   .....: </span>
<span class="gh">Out[216]: </span><span class="go"></span>
<span class="go">IntervalIndex([(2018-01-01, 2018-01-20 08:00:00], (2018-01-20 08:00:00, 2018-02-08 16:00:00], (2018-02-08 16:00:00, 2018-02-28]],</span>
<span class="go">              closed=&#39;right&#39;,</span>
<span class="go">              dtype=&#39;interval[datetime64[ns]]&#39;)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="miscellaneous-indexing-faq">
<h2>Miscellaneous indexing FAQ<a class="headerlink" href="#miscellaneous-indexing-faq" title="Permalink to this headline">¶</a></h2>
<div class="section" id="integer-indexing">
<h3>Integer indexing<a class="headerlink" href="#integer-indexing" title="Permalink to this headline">¶</a></h3>
<p>Label-based indexing with integer axis labels is a thorny topic. It has been
discussed heavily on mailing lists and among various members of the scientific
Python community. In pandas, our general viewpoint is that labels matter more
than integer locations. Therefore, with an integer axis index <em>only</em>
label-based indexing is possible with the standard tools like <code class="docutils literal notranslate"><span class="pre">.loc</span></code>. The
following code will generate exceptions:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [217]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

<span class="gp">In [218]: </span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">KeyError</span><span class="g g-Whitespace">                                  </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">218</span><span class="o">-</span><span class="mi">76</span><span class="n">c3dce40054</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="nn">~/scipy/pandas/pandas/core/series.py</span> in <span class="ni">__getitem__</span><span class="nt">(self, key)</span>
<span class="g g-Whitespace">    </span><span class="mi">814</span> 
<span class="g g-Whitespace">    </span><span class="mi">815</span>         <span class="k">try</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">816</span>             <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">817</span> 
<span class="g g-Whitespace">    </span><span class="mi">818</span>             <span class="k">return</span> <span class="n">result</span>

<span class="nn">~/scipy/pandas/pandas/core/indexes/base.py</span> in <span class="ni">get_value</span><span class="nt">(self, series, key)</span>
<span class="g g-Whitespace">   </span><span class="mi">4649</span>         <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_scalar_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;getitem&quot;</span><span class="p">)</span>
<span class="g g-Whitespace">   </span><span class="mi">4650</span>         <span class="k">try</span><span class="p">:</span>
<span class="ne">-&gt; </span><span class="mi">4651</span>             <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="g g-Whitespace">   </span><span class="mi">4652</span> 
<span class="g g-Whitespace">   </span><span class="mi">4653</span>         <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e1</span><span class="p">:</span>

<span class="nn">~/scipy/pandas/pandas/_libs/index.pyx</span> in <span class="ni">pandas._libs.index.IndexEngine.get_loc</span><span class="nt">()</span>

<span class="nn">~/scipy/pandas/pandas/_libs/index.pyx</span> in <span class="ni">pandas._libs.index.IndexEngine.get_loc</span><span class="nt">()</span>

<span class="nn">~/scipy/pandas/pandas/_libs/hashtable_class_helper.pxi</span> in <span class="ni">pandas._libs.hashtable.Int64HashTable.get_item</span><span class="nt">()</span>

<span class="nn">~/scipy/pandas/pandas/_libs/hashtable_class_helper.pxi</span> in <span class="ni">pandas._libs.hashtable.Int64HashTable.get_item</span><span class="nt">()</span>

<span class="ne">KeyError</span>: -1

<span class="gp">In [219]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="gp">In [220]: </span><span class="n">df</span>
<span class="gh">Out[220]: </span><span class="go"></span>
<span class="go">          0         1         2         3</span>
<span class="go">0 -0.130121 -0.476046  0.759104  0.213379</span>
<span class="go">1 -0.082641  0.448008  0.656420 -1.051443</span>
<span class="go">2  0.594956 -0.151360 -0.069303  1.221431</span>
<span class="go">3 -0.182832  0.791235  0.042745  2.069775</span>
<span class="go">4  1.446552  0.019814 -1.389212 -0.702312</span>

<span class="gp">In [221]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
<span class="gh">Out[221]: </span><span class="go"></span>
<span class="go">          0         1         2         3</span>
<span class="go">0 -0.130121 -0.476046  0.759104  0.213379</span>
<span class="go">1 -0.082641  0.448008  0.656420 -1.051443</span>
<span class="go">2  0.594956 -0.151360 -0.069303  1.221431</span>
<span class="go">3 -0.182832  0.791235  0.042745  2.069775</span>
<span class="go">4  1.446552  0.019814 -1.389212 -0.702312</span>
</pre></div>
</div>
<p>This deliberate decision was made to prevent ambiguities and subtle bugs (many
users reported finding bugs when the API change was made to stop “falling back”
on position-based indexing).</p>
</div>
<div class="section" id="non-monotonic-indexes-require-exact-matches">
<h3>Non-monotonic indexes require exact matches<a class="headerlink" href="#non-monotonic-indexes-require-exact-matches" title="Permalink to this headline">¶</a></h3>
<p>If the index of a <code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> is monotonically increasing or decreasing, then the bounds
of a label-based slice can be outside the range of the index, much like slice indexing a
normal Python <code class="docutils literal notranslate"><span class="pre">list</span></code>. Monotonicity of an index can be tested with the <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_monotonic_increasing()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">is_monotonic_decreasing()</span></code> attributes.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [222]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>

<span class="gp">In [223]: </span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
<span class="gh">Out[223]: </span><span class="go">True</span>

<span class="go"># no rows 0 or 1, but still returns rows 2, 3 (both of them), and 4:</span>
<span class="gp">In [224]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>
<span class="gh">Out[224]: </span><span class="go"></span>
<span class="go">   data</span>
<span class="go">2     0</span>
<span class="go">3     1</span>
<span class="go">3     2</span>
<span class="go">4     3</span>

<span class="go"># slice is are outside the index, so empty DataFrame is returned</span>
<span class="gp">In [225]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">15</span><span class="p">,</span> <span class="p">:]</span>
<span class="gh">Out[225]: </span><span class="go"></span>
<span class="go">Empty DataFrame</span>
<span class="go">Columns: [data]</span>
<span class="go">Index: []</span>
</pre></div>
</div>
<p>On the other hand, if the index is not monotonic, then both slice bounds must be
<em>unique</em> members of the index.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [226]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">   .....: </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="gp">   .....: </span>

<span class="gp">In [227]: </span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
<span class="gh">Out[227]: </span><span class="go">False</span>

<span class="go"># OK because 2 and 4 are in the index</span>
<span class="gp">In [228]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>
<span class="gh">Out[228]: </span><span class="go"></span>
<span class="go">   data</span>
<span class="go">2     0</span>
<span class="go">3     1</span>
<span class="go">1     2</span>
<span class="go">4     3</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># 0 is not in the index</span>
<span class="gp">In [9]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">KeyError: 0</span>

<span class="go"># 3 is not a unique label</span>
<span class="gp">In [11]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">KeyError: &#39;Cannot get right slice bound for non-unique label: 3&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Index.is_monotonic_increasing</span></code> and <code class="docutils literal notranslate"><span class="pre">Index.is_monotonic_decreasing</span></code> only check that
an index is weakly monotonic. To check for strict monotonicity, you can combine one of those with
the <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_unique()</span></code> attribute.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [229]: </span><span class="n">weakly_monotonic</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>

<span class="gp">In [230]: </span><span class="n">weakly_monotonic</span>
<span class="gh">Out[230]: </span><span class="go">Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="gp">In [231]: </span><span class="n">weakly_monotonic</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
<span class="gh">Out[231]: </span><span class="go">True</span>

<span class="gp">In [232]: </span><span class="n">weakly_monotonic</span><span class="o">.</span><span class="n">is_monotonic_increasing</span> <span class="o">&amp;</span> <span class="n">weakly_monotonic</span><span class="o">.</span><span class="n">is_unique</span>
<span class="gh">Out[232]: </span><span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="endpoints-are-inclusive">
<span id="advanced-endpoints-are-inclusive"></span><h3>Endpoints are inclusive<a class="headerlink" href="#endpoints-are-inclusive" title="Permalink to this headline">¶</a></h3>
<p>Compared with standard Python sequence slicing in which the slice endpoint is
not inclusive, label-based slicing in pandas <strong>is inclusive</strong>. The primary
reason for this is that it is often not possible to easily determine the
“successor” or next element after a particular label in an index. For example,
consider the following <code class="docutils literal notranslate"><span class="pre">Series</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [233]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abcdef&#39;</span><span class="p">))</span>

<span class="gp">In [234]: </span><span class="n">s</span>
<span class="gh">Out[234]: </span><span class="go"></span>
<span class="go">a    0.301379</span>
<span class="go">b    1.240445</span>
<span class="go">c   -0.846068</span>
<span class="go">d   -0.043312</span>
<span class="go">e   -1.658747</span>
<span class="go">f   -0.819549</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Suppose we wished to slice from <code class="docutils literal notranslate"><span class="pre">c</span></code> to <code class="docutils literal notranslate"><span class="pre">e</span></code>, using integers this would be
accomplished as such:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [235]: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="gh">Out[235]: </span><span class="go"></span>
<span class="go">c   -0.846068</span>
<span class="go">d   -0.043312</span>
<span class="go">e   -1.658747</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>However, if you only had <code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">e</span></code>, determining the next element in the
index can be somewhat complicated. For example, the following does not work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="s1">&#39;e&#39;</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>A very common use case is to limit a time series to start and end at two
specific dates. To enable this, we made the design choice to make label-based
slicing include both endpoints:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [236]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="s1">&#39;e&#39;</span><span class="p">]</span>
<span class="gh">Out[236]: </span><span class="go"></span>
<span class="go">c   -0.846068</span>
<span class="go">d   -0.043312</span>
<span class="go">e   -1.658747</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>This is most definitely a “practicality beats purity” sort of thing, but it is
something to watch out for if you expect label-based slicing to behave exactly
in the way that standard Python integer slicing works.</p>
</div>
<div class="section" id="indexing-potentially-changes-underlying-series-dtype">
<h3>Indexing potentially changes underlying Series dtype<a class="headerlink" href="#indexing-potentially-changes-underlying-series-dtype" title="Permalink to this headline">¶</a></h3>
<p>The different indexing operation can potentially change the dtype of a <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [237]: </span><span class="n">series1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="gp">In [238]: </span><span class="n">series1</span><span class="o">.</span><span class="n">dtype</span>
<span class="gh">Out[238]: </span><span class="go">dtype(&#39;int64&#39;)</span>

<span class="gp">In [239]: </span><span class="n">res</span> <span class="o">=</span> <span class="n">series1</span><span class="o">.</span><span class="n">reindex</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

<span class="gp">In [240]: </span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span>
<span class="gh">Out[240]: </span><span class="go">dtype(&#39;float64&#39;)</span>

<span class="gp">In [241]: </span><span class="n">res</span>
<span class="gh">Out[241]: </span><span class="go"></span>
<span class="go">0    1.0</span>
<span class="go">4    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [242]: </span><span class="n">series2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="bp">True</span><span class="p">])</span>

<span class="gp">In [243]: </span><span class="n">series2</span><span class="o">.</span><span class="n">dtype</span>
<span class="gh">Out[243]: </span><span class="go">dtype(&#39;bool&#39;)</span>

<span class="gp">In [244]: </span><span class="n">res</span> <span class="o">=</span> <span class="n">series2</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="n">series1</span><span class="p">)</span>

<span class="gp">In [245]: </span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span>
<span class="gh">Out[245]: </span><span class="go">dtype(&#39;O&#39;)</span>

<span class="gp">In [246]: </span><span class="n">res</span>
<span class="gh">Out[246]: </span><span class="go"></span>
<span class="go">0    True</span>
<span class="go">1     NaN</span>
<span class="go">2     NaN</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>This is because the (re)indexing operations above silently inserts <code class="docutils literal notranslate"><span class="pre">NaNs</span></code> and the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
changes accordingly.  This can cause some issues when using <code class="docutils literal notranslate"><span class="pre">numpy</span></code> <code class="docutils literal notranslate"><span class="pre">ufuncs</span></code>
such as <code class="docutils literal notranslate"><span class="pre">numpy.logical_and</span></code>.</p>
<p>See the <a class="reference external" href="https://github.com/pydata/pandas/issues/2388">this old issue</a> for a more
detailed discussion.</p>
</div>
</div>
</div>


              </div>
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="indexing.html" title="previous page">Indexing and selecting data</a>
    <a class='right-next' id="next-link" href="merging.html" title="next page">Merge, join, and concatenate</a>

              </div>
              
          </main>

      </div>
    </div><script>
    // TOC sidebar - add "active" class to parent list
    //
    // Bootstrap's scrollspy adds the active class to the <a> link,
    // but for the automatic collapsing we need this on the parent list item.
    //
    // The event is triggered on "window" (and not the nav item as documented),
    // see https://github.com/twbs/bootstrap/issues/20086
    $(window).on("activate.bs.scrollspy", function(){
    var navLinks = document.querySelectorAll('#bd-toc-nav a');
    for (var i = 0; i < navLinks.length; i++) {
        var navLink = navLinks[i];
        navLink.parentElement.classList.remove('active');
    }
    var navLinks = document.querySelectorAll('#bd-toc-nav a.active');
    for (var i = 0; i < navLinks.length; i++) {
        var navLink = navLinks[i];
        navLink.parentElement.classList.add('active');
    }
    });

    /**
     * Use left and right arrow keys to navigate forward and backwards.
    */
    const LEFT_ARROW_KEYCODE = 37
    const RIGHT_ARROW_KEYCODE = 39

    const getPrevUrl = () => document.getElementById('prev-link').href
    const getNextUrl = () => document.getElementById('next-link').href
    const initPageNav = (event) => {
        const keycode = event.which

        if (keycode === LEFT_ARROW_KEYCODE) {
            window.location.href = getPrevUrl();
        } else if (keycode === RIGHT_ARROW_KEYCODE) {
            window.location.href = getNextUrl();
        }
    };

    var keyboardListener = false;
    $( document ).ready(() => {
        if (keyboardListener === false) {
            document.addEventListener('keydown', initPageNav)
            keyboardListener = true;
        }
    });
</script>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2020, the pandas development team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.0.
    </div>
  </body>
</html>